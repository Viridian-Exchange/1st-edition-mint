import { AxiosRequestConfig } from 'axios';
import { Signer } from 'ethers';
import * as T from 'fp-ts/Task';
import * as TE from 'fp-ts/TaskEither';
import { EthAddress, HexadecimalString, ImmutableMethodParams, ImmutableMethodResults, OrderParams, PositiveBigNumber, Token } from '../types';
import { ImmutableXWallet } from './ImmutableXWallet';
export declare type ImmutableXClientParams = {
    publicApiUrl: string;
    signer?: Signer;
    gasLimit?: string;
    gasPrice?: string;
    starkContractAddress?: string;
    registrationContractAddress?: string;
};
export declare class ImmutableXClient {
    private publicApiUrl;
    private wallet;
    private contractAddress;
    private registrationContractAddress;
    private _address;
    private _starkPublicKey;
    private agent;
    constructor(publicApiUrl: string, wallet: ImmutableXWallet, contractAddress: EthAddress, registrationContractAddress: EthAddress, _address: EthAddress, _starkPublicKey: HexadecimalString);
    static buildF(params: ImmutableXClientParams): TE.TaskEither<Error, ImmutableXClient>;
    getERC20Balance(owner: string, contractAddress: string): Promise<string>;
    static build({ publicApiUrl, signer, starkContractAddress, registrationContractAddress, gasLimit, gasPrice, }: ImmutableXClientParams): Promise<ImmutableXClient>;
    get address(): import("io-ts").Branded<string, import("../types").EthAddressBrand>;
    get starkPublicKey(): import("io-ts").Branded<string, import("../types").HexadecimalStringBrand>;
    buildOptions(): AxiosRequestConfig;
    private replaceApiVersion;
    private get;
    private post;
    private delete;
    registerImxF({ etherKey, starkPublicKey, }: ImmutableMethodParams.ImmutableRegisterParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableRegisterResult>;
    getUserF(params: ImmutableMethodParams.ImmutableGetUserParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetUserResult>;
    getUser(params: ImmutableMethodParams.ImmutableGetUserParamsTS): Promise<{
        accounts: import("io-ts").Branded<string, import("../types").HexadecimalStringBrand>[];
    }>;
    registerImx(params: ImmutableMethodParams.ImmutableRegisterParamsTS): Promise<{
        tx_hash: string;
    }>;
    isRegisteredF(params: ImmutableMethodParams.ImmutableGetUserParams): TE.TaskEither<Error, boolean>;
    isRegistered(params: ImmutableMethodParams.ImmutableGetUserParamsTS): Promise<boolean>;
    isRegisteredStarkF(starkPublicKey: string): T.Task<boolean>;
    isRegisteredStark(starkPublicKey: string): Promise<boolean>;
    registerF(params: ImmutableMethodParams.ImmutableRegisterParams): TE.TaskEither<Error, string>;
    register(params: ImmutableMethodParams.ImmutableRegisterParamsTS): Promise<string>;
    registerStarkF({ etherKey, starkPublicKey, operatorSignature, }: ImmutableMethodParams.ImmutableStarkRegisterParams): TE.TaskEither<Error, string>;
    registerStark(params: ImmutableMethodParams.ImmutableStarkRegisterParamsTS): Promise<string>;
    getSignableRegistrationF({ etherKey, starkPublicKey, }: ImmutableMethodParams.ImmutableGetSignableRegistrationParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetSignableRegistrationResult>;
    getSignableRegistration(params: ImmutableMethodParams.ImmutableGetSignableRegistrationParamsTS): Promise<{
        operator_signature: string;
    }>;
    mintNFTF({ tokenAddress, }: ImmutableMethodParams.ImmutableMintNFTParams): TE.TaskEither<Error, string>;
    mintNFT(params: ImmutableMethodParams.ImmutableMintNFTParamsTS): Promise<string>;
    approveNFTF(params: ImmutableMethodParams.ImmutableStarkApproveNFTParams): TE.TaskEither<Error, string>;
    approveNFT(params: ImmutableMethodParams.ImmutableStarkApproveNFTParamsTS): Promise<string>;
    depositF({ user, token, quantity, }: ImmutableMethodParams.ImmutableGetSignableDepositParams): TE.TaskEither<Error, string>;
    deposit(params: ImmutableMethodParams.ImmutableGetSignableDepositParamsTS): Promise<string>;
    depositCancel(starkPublicKey: string, token: Token, vaultId: string): Promise<any>;
    depositReclaim(starkPublicKey: string, token: Token, vaultId: string): Promise<any>;
    prepareWithdrawalF({ user, token, quantity, }: ImmutableMethodParams.ImmutablePrepareWithdrawalParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableWithdrawalResult>;
    prepareWithdrawal(params: ImmutableMethodParams.ImmutablePrepareWithdrawalParamsTS): Promise<ImmutableMethodResults.ImmutableWithdrawalResult>;
    completeWithdrawalF({ starkPublicKey, token, }: ImmutableMethodParams.ImmutableCompleteWithdrawalParams): TE.TaskEither<Error, string>;
    completeWithdrawal(params: ImmutableMethodParams.ImmutableCompleteWithdrawalParamsTS): Promise<string>;
    transferF({ sender, token, quantity, receiver, }: ImmutableMethodParams.ImmutableTransferParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableTransferResult>;
    transfer(params: ImmutableMethodParams.ImmutableTransferParamsTS): Promise<ImmutableMethodResults.ImmutableTransferResult>;
    mintF(params: ImmutableMethodParams.ImmutableOffchainMintParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableOffchainMintResults>;
    mint(params: ImmutableMethodParams.ImmutableOffchainMintParamsTS): Promise<ImmutableMethodResults.ImmutableOffchainMintResults>;
    mintV2F(params: ImmutableMethodParams.ImmutableOffchainMintV2Params): TE.TaskEither<Error, ImmutableMethodResults.ImmutableOffchainMintV2Result>;
    mintV2(params: ImmutableMethodParams.ImmutableOffchainMintV2ParamsTS): Promise<ImmutableMethodResults.ImmutableOffchainMintV2Result>;
    calculateMakerOrderAmountsF({ tokenSell, tokenBuy, amountSell, amountBuy, }: ImmutableMethodParams.ImmutableGetSignableOrderParams): TE.TaskEither<Error, {
        amountSell: PositiveBigNumber;
        amountBuy: PositiveBigNumber;
    }>;
    createOrderRequestF({ user, tokenSell, tokenBuy, amountSell, amountBuy, include_fees, }: ImmutableMethodParams.ImmutableGetSignableOrderParams): TE.TaskEither<Error, {
        signableOrderResult: ImmutableMethodResults.ImmutableGetSignableOrderResult;
        sellParams: OrderParams;
        buyParams: OrderParams;
        signature: string;
    }>;
    createOrderF({ user, tokenSell, tokenBuy, amountSell, amountBuy, include_fees, }: ImmutableMethodParams.ImmutableGetSignableOrderParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCreateOrderResult>;
    createOrder(params: ImmutableMethodParams.ImmutableGetSignableOrderParamsTS): Promise<ImmutableMethodResults.ImmutableCreateOrderResult>;
    cancelOrder(orderId: number): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCancelOrderResult>;
    createTradeF({ user, tokenSell, tokenBuy, amountSell, amountBuy, orderId, include_fees, }: ImmutableMethodParams.ImmutableGetSignableTradeParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCreateTradeResult>;
    createTrade(params: ImmutableMethodParams.ImmutableGetSignableTradeParamsTS): Promise<ImmutableMethodResults.ImmutableCreateTradeResult>;
    getTokenF(params: ImmutableMethodParams.ImmutableGetTokenParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetTokenResult>;
    getToken(params: ImmutableMethodParams.ImmutableGetTokenParamsTS): Promise<ImmutableMethodResults.ImmutableGetTokenResult>;
    listTokensF(params: ImmutableMethodParams.ImmutableListTokensParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableListTokensResult>;
    listTokens(params: ImmutableMethodParams.ImmutableListTokensParamsTS): Promise<ImmutableMethodResults.ImmutableListTokensResult>;
    getBalancesF(params: ImmutableMethodParams.ImmutableGetBalancesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetBalancesResult>;
    getBalances(params: ImmutableMethodParams.ImmutableGetBalancesParams): Promise<ImmutableMethodResults.ImmutableGetBalancesResult>;
    getBalanceF(params: ImmutableMethodParams.ImmutableGetBalanceParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetBalanceResult>;
    getBalance(params: ImmutableMethodParams.ImmutableGetBalanceParamsTS): Promise<ImmutableMethodResults.ImmutableGetBalanceResult>;
    listBalancesF({ user, symbols, cursor, }: ImmutableMethodParams.ImmutableListBalancesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableListBalancesResult>;
    listBalances(params: ImmutableMethodParams.ImmutableListBalancesParamsTS): Promise<ImmutableMethodResults.ImmutableListBalancesResult>;
    getMintableTokenF(params: ImmutableMethodParams.ImmutableGetMintableTokenParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetMintableTokenResult>;
    getMintableToken(params: ImmutableMethodParams.ImmutableGetMintableTokenParamsTS): Promise<ImmutableMethodResults.ImmutableGetMintableTokenResult>;
    getVaults(starkPublicKey: string): Promise<any>;
    getOrderF({ orderId, include_fees, }: ImmutableMethodParams.ImmutableGetOrderParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetOrderResult>;
    getOrder(params: ImmutableMethodParams.ImmutableGetOrderParamsTS): Promise<ImmutableMethodResults.ImmutableGetOrderResult>;
    getOrdersF(query: ImmutableMethodParams.ImmutableGetOrdersParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetOrdersResult>;
    getOrders(params?: ImmutableMethodParams.ImmutableGetOrdersParamsTS): Promise<ImmutableMethodResults.ImmutableGetOrdersResult>;
    getAssetsF(query: ImmutableMethodParams.ImmutableGetAssetsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetAssetsResult>;
    getAssets(params?: ImmutableMethodParams.ImmutableGetAssetsParamsTS): Promise<ImmutableMethodResults.ImmutableGetAssetsResult>;
    getAssetF({ address, id, include_fees, }: ImmutableMethodParams.ImmutableGetAssetParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableAsset>;
    getAsset(params: ImmutableMethodParams.ImmutableGetAssetParamsTS): Promise<ImmutableMethodResults.ImmutableAsset>;
    getApplicationsF(query?: ImmutableMethodParams.ImmutableGetApplicationsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetApplicationsResult>;
    getApplications(params?: ImmutableMethodParams.ImmutableGetApplicationsParamsTS): Promise<ImmutableMethodResults.ImmutableGetApplicationsResult>;
    getTradeF({ id, }: ImmutableMethodParams.ImmutableGetTradeParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableTrade>;
    getTrade(params: ImmutableMethodParams.ImmutableGetTradeParamsTS): Promise<ImmutableMethodResults.ImmutableTrade>;
    getCollectionsF(query: ImmutableMethodParams.ImmutableGetCollectionsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetCollectionsResult>;
    getCollections(params: ImmutableMethodParams.ImmutableGetCollectionsParamsTS): Promise<ImmutableMethodResults.ImmutableGetCollectionsResult>;
    getCollectionF({ address, }: ImmutableMethodParams.ImmutableGetCollectionParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCollection>;
    getCollection(params: ImmutableMethodParams.ImmutableGetCollectionParamsTS): Promise<ImmutableMethodResults.ImmutableCollection>;
    getDepositsF(query?: ImmutableMethodParams.ImmutableGetDepositsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetDepositsResult>;
    getDeposits(params?: ImmutableMethodParams.ImmutableGetDepositsParamsTS): Promise<ImmutableMethodResults.ImmutableGetDepositsResult>;
    getDepositF({ id, }: ImmutableMethodParams.ImmutableGetDepositParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableDeposit>;
    getDeposit(params: ImmutableMethodParams.ImmutableGetDepositParamsTS): Promise<ImmutableMethodResults.ImmutableDeposit>;
    getTransferF({ id, }: ImmutableMethodParams.ImmutableGetTransferParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableTransfer>;
    getTransfer(params: ImmutableMethodParams.ImmutableGetTransferParamsTS): Promise<ImmutableMethodResults.ImmutableTransfer>;
    getWithdrawalF({ id, }: ImmutableMethodParams.ImmutableGetWithdrawalParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableWithdrawal>;
    getWithdrawal(params: ImmutableMethodParams.ImmutableGetWithdrawalParamsTS): Promise<ImmutableMethodResults.ImmutableWithdrawal>;
    getWithdrawalsF(query?: ImmutableMethodParams.ImmutableGetWithdrawalsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetWithdrawalsResult>;
    getWithdrawals(params?: ImmutableMethodParams.ImmutableGetWithdrawalsParamsTS): Promise<ImmutableMethodResults.ImmutableGetWithdrawalsResult>;
    getTransfersF(query?: ImmutableMethodParams.ImmutableGetTransfersParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetTransfersResult>;
    getTransfers(params?: ImmutableMethodParams.ImmutableGetTransfersParamsTS): Promise<ImmutableMethodResults.ImmutableGetTransfersResult>;
    getTradesF(query?: ImmutableMethodParams.ImmutableGetTradesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetTradesResult>;
    getPaginatedResults<P, T>(params: P, fn: (params: P) => TE.TaskEither<Error, {
        cursor: string;
        result: T[];
    }>): TE.TaskEither<Error, T[]>;
    getTrades(params?: ImmutableMethodParams.ImmutableGetTradesParamsTS): Promise<ImmutableMethodResults.ImmutableGetTradesResult>;
    getLastAvailableNonce(starkPublicKey: string): Promise<{
        Nonce: string;
    }>;
    getTokenBody(token: Token): any;
    private decodeForFunction;
}
export default ImmutableXClient;
