{"ast":null,"code":"import config from \"../local-dev-config\";\nimport vGPJSON from \"../abis/ViridianGenesisPack.json\";\nimport { Biconomy } from \"@biconomy/mexa\";\nimport Web3 from \"web3\";\nimport { useWeb3React } from \"@web3-react/core\";\nlet web3Wallet = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\")); //\n\nlet web3WS = new Web3(new Web3.providers.WebsocketProvider(\"wss://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\")); //\n\nlet web3 = new Web3(Web3.givenProvider); // || new Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n// export async function tokenURI(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS: \" + tokenId);\n//     let nft = vNFTABI.methods.tokenURI(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return nft;\n// }\n//\n// export async function ownerOf(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS1: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function ownerOfNoReq(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS2: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function setApprovalForAll(from, exchangeAddress) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.setApprovalForAll(exchangeAddress, true).send({from: from});\n// }\n\nexport async function mint(from, numMint, setSuccess, setFailed, setMinting, library) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new library.eth.Contract(vGPJSON['abi'], vNFTContractAddress); //alert((100000000000000000 * numMint).toString());\n\n  try {\n    //let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //console.log('checking transfer event')\n    // await vNFTABIWS.events.Transfer({filter: {to: from}}).on('data', async function (event) {\n    //     alert(\"BREH\")\n    //     setSuccess(true);\n    //     setFailed(false);\n    //     setMinting(false);\n    // }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n    await vNFTABI.methods.mint(numMint, from).send({\n      from: from,\n      value: (200000000000000000 * numMint).toString()\n    });\n  } catch (e) {\n    console.error(e);\n    setFailed(true);\n    setMinting(false);\n    setTimeout(() => {\n      setFailed(false);\n    }, \"5000\");\n  }\n}\nexport async function open(from, tokenId, setSuccess, setFailed, setMinting) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3.eth.Contract(vGPJSON['abi'], vNFTContractAddress); //alert((100000000000000000 * numMint).toString());\n\n  alert(tokenId);\n\n  try {\n    await vNFTABI.methods.open(tokenId).send({\n      from: from\n    }); // let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //\n    // await vNFTABIWS.events.Transfer({filter: {from: from}}).on('data', async function (event) {\n    //     setSuccess(true);\n    //     setFailed(false);\n    //     setMinting(false);\n    // }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n  } catch (e) {\n    console.error(e); //setFailed(true);\n\n    setMinting(false);\n  }\n}\nexport async function openTo(from, to, tokenId, setSuccess, setFailed, setMinting) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3.eth.Contract(vGPJSON['abi'], vNFTContractAddress); //alert((100000000000000000 * numMint).toString());\n  //alert(tokenId);\n\n  try {\n    await vNFTABI.methods.openTo(tokenId, to).send({\n      from: from\n    }); // let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //\n    // await vNFTABIWS.events.Transfer({filter: {from: from}}).on('data', async function (event) {\n    //     setSuccess(true);\n    //     setFailed(false);\n    //     setMinting(false);\n    // }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n  } catch (e) {\n    console.error(e); //setFailed(true);\n\n    setMinting(false);\n  }\n} // export async function bridge(from, bridgeNFTs) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n//\n//     let vNFTABI = new biconomyWeb3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.bridge(bridgeNFTs).send({from: from});\n// }\n\nexport async function totalSupply() {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  //if (web3) {\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  return await vNFTABI.methods.totalSupply().call(); //}\n  //return await vNFTABI.methods.getNumNFTs().call();\n}\nexport async function isWhitelistMintingEnabled() {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  //if (web3) {\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  return await vNFTABI.methods.isWhitelistMintingEnabled().call(); //}\n  //return await vNFTABI.methods.getNumNFTs().call();\n}\nexport async function isPublicMintingEnabled() {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  //if (web3) {\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  return await vNFTABI.methods.isPublicMintingEnabled().call(); //}\n  //return await vNFTABI.methods.getNumNFTs().call();\n}\nexport async function isAddressWhitelisted(address) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  //if (web3) {\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  return await vNFTABI.methods.isAddressWhitelisted().call(); //}\n  //return await vNFTABI.methods.getNumNFTs().call();\n}\nexport async function getOwnedNFTs(from) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract; //alert(from)\n\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  let ownedNFTS = await vNFTABI.methods.getOwnedNFTs().call({\n    from: from\n  }); //alert(ownedNFTS);\n\n  return ownedNFTS;\n}\nexport async function tokenURI(tokenID, from) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract; //alert(from)\n\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  let ownedNFTS = await vNFTABI.methods.tokenURI(tokenID).call({\n    from: from\n  }); //alert(ownedNFTS);\n\n  return ownedNFTS;\n} //\n// export async function isApprovedForAll(owner, operator) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.isApprovedForAll(owner, operator).call();\n// }\n// export async function safeTransferFrom(from, to, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.safeTransferFrom(from, to, tokenId).send({from: from});\n// }\n//\n// export async function burn(from, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.burn(tokenId).send({from: from, signatureType: biconomy.EIP712_SIGN});\n// }","map":{"version":3,"sources":["/Users/blakehatch/WebstormProjects/1st-edition-mint/src/smartContracts/ViridianGenPassMethods.js"],"names":["config","vGPJSON","Biconomy","Web3","useWeb3React","web3Wallet","givenProvider","providers","HttpProvider","web3WS","WebsocketProvider","web3","mint","from","numMint","setSuccess","setFailed","setMinting","library","vNFTContractAddress","rinkeby_contract_addresses","vgp_contract","vNFTABI","eth","Contract","methods","send","value","toString","e","console","error","setTimeout","open","tokenId","alert","openTo","to","totalSupply","call","isWhitelistMintingEnabled","isPublicMintingEnabled","isAddressWhitelisted","address","getOwnedNFTs","ownedNFTS","tokenURI","tokenID"],"mappings":"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","sourcesContent":["import config from \"../local-dev-config\";\nimport vGPJSON from \"../abis/ViridianGenesisPack.json\";\nimport {Biconomy} from \"@biconomy/mexa\";\nimport Web3 from \"web3\";\nimport {useWeb3React} from \"@web3-react/core\";\n\nlet web3Wallet = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n//\nlet web3WS = new Web3(new Web3.providers.WebsocketProvider( \"wss://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n//\nlet web3 = new Web3(Web3.givenProvider);// || new Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n\n// export async function tokenURI(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS: \" + tokenId);\n//     let nft = vNFTABI.methods.tokenURI(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return nft;\n// }\n//\n// export async function ownerOf(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS1: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function ownerOfNoReq(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS2: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function setApprovalForAll(from, exchangeAddress) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.setApprovalForAll(exchangeAddress, true).send({from: from});\n// }\n\nexport async function mint(from, numMint, setSuccess, setFailed, setMinting, library) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new library.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //alert((100000000000000000 * numMint).toString());\n    try {\n        //let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n        //console.log('checking transfer event')\n        // await vNFTABIWS.events.Transfer({filter: {to: from}}).on('data', async function (event) {\n        //     alert(\"BREH\")\n        //     setSuccess(true);\n        //     setFailed(false);\n        //     setMinting(false);\n        // }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n\n\n        await vNFTABI.methods.mint(numMint, from).send({\n            from: from, value: (200000000000000000 * numMint).toString(),\n        });\n\n\n    } catch(e) {\n        console.error(e);\n        setFailed(true);\n        setMinting(false);\n        setTimeout(() => {\n            setFailed(false);\n        }, \"5000\");\n    }\n}\n\nexport async function open(from, tokenId, setSuccess, setFailed, setMinting) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //alert((100000000000000000 * numMint).toString());\n    alert(tokenId);\n    try {\n        await vNFTABI.methods.open(tokenId).send({\n            from: from\n        });\n\n        // let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n        //\n        // await vNFTABIWS.events.Transfer({filter: {from: from}}).on('data', async function (event) {\n        //     setSuccess(true);\n        //     setFailed(false);\n        //     setMinting(false);\n        // }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n\n    } catch(e) {\n        console.error(e);\n        //setFailed(true);\n        setMinting(false);\n    }\n}\n\nexport async function openTo(from, to, tokenId, setSuccess, setFailed, setMinting) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //alert((100000000000000000 * numMint).toString());\n    //alert(tokenId);\n    try {\n        await vNFTABI.methods.openTo(tokenId, to).send({\n            from: from\n        });\n\n        // let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n        //\n        // await vNFTABIWS.events.Transfer({filter: {from: from}}).on('data', async function (event) {\n        //     setSuccess(true);\n        //     setFailed(false);\n        //     setMinting(false);\n        // }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n\n    } catch(e) {\n        console.error(e);\n        //setFailed(true);\n        setMinting(false);\n    }\n}\n\n// export async function bridge(from, bridgeNFTs) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n//\n//     let vNFTABI = new biconomyWeb3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.bridge(bridgeNFTs).send({from: from});\n// }\n\nexport async function totalSupply() {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    //if (web3) {\n        const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n        let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n        return await vNFTABI.methods.totalSupply().call();\n    //}\n    //return await vNFTABI.methods.getNumNFTs().call();\n}\n\nexport async function isWhitelistMintingEnabled() {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    //if (web3) {\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    return await vNFTABI.methods.isWhitelistMintingEnabled().call();\n    //}\n    //return await vNFTABI.methods.getNumNFTs().call();\n}\n\nexport async function isPublicMintingEnabled() {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    //if (web3) {\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    return await vNFTABI.methods.isPublicMintingEnabled().call();\n    //}\n    //return await vNFTABI.methods.getNumNFTs().call();\n}\n\nexport async function isAddressWhitelisted(address) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    //if (web3) {\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    return await vNFTABI.methods.isAddressWhitelisted().call();\n    //}\n    //return await vNFTABI.methods.getNumNFTs().call();\n}\n\n\nexport async function getOwnedNFTs(from) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n    //alert(from)\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    let ownedNFTS = await vNFTABI.methods.getOwnedNFTs().call({from: from});\n    //alert(ownedNFTS);\n    return ownedNFTS;\n}\n\nexport async function tokenURI(tokenID, from) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n    //alert(from)\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    let ownedNFTS = await vNFTABI.methods.tokenURI(tokenID).call({from: from});\n    //alert(ownedNFTS);\n    return ownedNFTS;\n}\n\n//\n// export async function isApprovedForAll(owner, operator) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.isApprovedForAll(owner, operator).call();\n// }\n\n// export async function safeTransferFrom(from, to, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.safeTransferFrom(from, to, tokenId).send({from: from});\n// }\n//\n// export async function burn(from, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.burn(tokenId).send({from: from, signatureType: biconomy.EIP712_SIGN});\n// }"]},"metadata":{},"sourceType":"module"}