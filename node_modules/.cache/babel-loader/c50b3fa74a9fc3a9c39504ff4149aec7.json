{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useState, useContext, useEffect } from \"react\";\nimport CryptoPriceContext from \"./CryptoPriceContext\";\n\nvar useCryptoPrices = function (symbols) {\n  var _a = __read(useState(false), 2),\n      streamOpen = _a[0],\n      setStreamOpen = _a[1];\n\n  var _b = __read(useState({}), 2),\n      data = _b[0],\n      setData = _b[1];\n\n  var priceContext = useContext(CryptoPriceContext);\n  var assets = priceContext.assets,\n      prices = priceContext.prices,\n      streamPrices = priceContext.streamPrices;\n  useEffect(function () {\n    if (!streamOpen && assets.length > 0) {\n      streamPrices(symbols);\n      setStreamOpen(true);\n    }\n  }, [assets, symbols, streamOpen]);\n  useEffect(function () {\n    if (prices) {\n      setData(__assign(__assign({}, data), prices));\n    }\n  }, [prices]);\n  return data;\n};\n\nexport default useCryptoPrices;","map":{"version":3,"sources":["../src/useCryptoPrices.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAgB,QAAhB,EAA0B,UAA1B,EAAsC,SAAtC,QAAuD,OAAvD;AACA,OAAO,kBAAP,MAA+B,sBAA/B;;AAEA,IAAM,eAAe,GAAG,UAAC,OAAD,EAAuB;AACrC,MAAA,EAAA,GAAA,MAAA,CAA8B,QAAQ,CAAC,KAAD,CAAtC,EAA6C,CAA7C,CAAA;AAAA,MAAC,UAAU,GAAA,EAAA,CAAA,CAAA,CAAX;AAAA,MAAa,aAAa,GAAA,EAAA,CAAA,CAAA,CAA1B;;AACA,MAAA,EAAA,GAAA,MAAA,CAAkB,QAAQ,CAAC,EAAD,CAA1B,EAA8B,CAA9B,CAAA;AAAA,MAAC,IAAI,GAAA,EAAA,CAAA,CAAA,CAAL;AAAA,MAAO,OAAO,GAAA,EAAA,CAAA,CAAA,CAAd;;AACN,MAAM,YAAY,GAAG,UAAU,CAAC,kBAAD,CAA/B;AACQ,MAAA,MAAM,GAA2B,YAAY,CAAvC,MAAN;AAAA,MAAQ,MAAM,GAAmB,YAAY,CAA/B,MAAd;AAAA,MAAgB,YAAY,GAAK,YAAY,CAAjB,YAA5B;AAER,EAAA,SAAS,CAAC,YAAA;AACN,QAAI,CAAC,UAAD,IAAe,MAAM,CAAC,MAAP,GAAgB,CAAnC,EAAsC;AAClC,MAAA,YAAY,CAAC,OAAD,CAAZ;AACA,MAAA,aAAa,CAAC,IAAD,CAAb;AACH;AACJ,GALQ,EAKN,CAAC,MAAD,EAAS,OAAT,EAAkB,UAAlB,CALM,CAAT;AAOA,EAAA,SAAS,CAAC,YAAA;AACN,QAAI,MAAJ,EAAY;AACR,MAAA,OAAO,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,IAAN,CAAA,EAAe,MAAf,CAAA,CAAP;AACH;AACJ,GAJQ,EAIN,CAAC,MAAD,CAJM,CAAT;AAMA,SAAO,IAAP;AACH,CApBD;;AAsBA,eAAe,eAAf","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { useState, useContext, useEffect } from \"react\";\nimport CryptoPriceContext from \"./CryptoPriceContext\";\nvar useCryptoPrices = function (symbols) {\n    var _a = __read(useState(false), 2), streamOpen = _a[0], setStreamOpen = _a[1];\n    var _b = __read(useState({}), 2), data = _b[0], setData = _b[1];\n    var priceContext = useContext(CryptoPriceContext);\n    var assets = priceContext.assets, prices = priceContext.prices, streamPrices = priceContext.streamPrices;\n    useEffect(function () {\n        if (!streamOpen && assets.length > 0) {\n            streamPrices(symbols);\n            setStreamOpen(true);\n        }\n    }, [assets, symbols, streamOpen]);\n    useEffect(function () {\n        if (prices) {\n            setData(__assign(__assign({}, data), prices));\n        }\n    }, [prices]);\n    return data;\n};\nexport default useCryptoPrices;\n//# sourceMappingURL=useCryptoPrices.js.map"]},"metadata":{},"sourceType":"module"}