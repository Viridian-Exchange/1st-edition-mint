{"ast":null,"code":"import config from \"../local-dev-config\";\nimport vGPJSON from \"../abis/ViridianGenesisPack.json\";\nimport { Biconomy } from \"@biconomy/mexa\";\nimport Web3 from \"web3\";\nlet web3Wallet = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\nlet web3WS = new Web3(new Web3.providers.WebsocketProvider(\"wss://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\nconst biconomy = new Biconomy(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"), {\n  apiKey: \"TVCsgQVfk.a6031565-1cb6-40da-8a60-2ffec22e3bed\",\n  debug: true\n});\nlet biconomyWeb3 = new Web3(biconomy); // biconomy.onEvent(biconomy.READY, () => {\n//     // Initialize your dapp here like getting user accounts etc\n//     console.log(\"initialized\");\n// }).onEvent(biconomy.ERROR, (error, message) => {\n//     // Handle error while initializing mexa\n//     console.error(error);\n// });\n// export async function tokenURI(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS: \" + tokenId);\n//     let nft = vNFTABI.methods.tokenURI(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return nft;\n// }\n//\n// export async function ownerOf(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS1: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function ownerOfNoReq(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS2: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function setApprovalForAll(from, exchangeAddress) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.setApprovalForAll(exchangeAddress, true).send({from: from});\n// }\n\nexport async function mint(from, numMint, setSuccess, setFailed, setMinting) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress); //alert((100000000000000000 * numMint).toString());\n\n  try {\n    await vNFTABI.methods.mint(numMint, from).send({\n      from: from,\n      value: (100000000000000000 * numMint).toString() //signatureType: biconomy.EIP712_SIGN\n\n    });\n    let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    await vNFTABIWS.events.Transfer({\n      filter: {\n        from: from\n      }\n    }).on('data', async function (event) {\n      setSuccess(true);\n      setFailed(false);\n      setMinting(false);\n    }).on('err', e => {\n      console.error(e);\n      setFailed(true);\n      setMinting(false);\n    });\n  } catch (e) {\n    setFailed(true);\n    setMinting(false);\n    console.error(e);\n  }\n}\nexport async function openPack(from, tokenId, setSuccess, setFailed, setMinting) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress); //alert((100000000000000000 * numMint).toString());\n\n  try {\n    await vNFTABI.methods.openPack(tokenId).send({\n      from: from,\n      signatureType: biconomy.EIP712_SIGN\n    });\n    let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    await vNFTABIWS.events.Transfer({\n      filter: {\n        from: from\n      }\n    }).on('data', async function (event) {\n      setSuccess(true);\n      setFailed(false);\n      setMinting(false);\n    }).on('err', e => {\n      console.error(e);\n      setFailed(true);\n      setMinting(false);\n    });\n  } catch (e) {\n    setFailed(true);\n    setMinting(false);\n    console.error(e);\n  }\n} // export async function bridge(from, bridgeNFTs) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n//\n//     let vNFTABI = new biconomyWeb3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.bridge(bridgeNFTs).send({from: from});\n// }\n\nexport async function totalSupply(from) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  return await vNFTABI.methods.totalSupply().call(); //return await vNFTABI.methods.getNumNFTs().call();\n}\nexport async function getOwnedNFTs(from) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract; //alert(from)\n\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  let ownedNFTS = await vNFTABI.methods.getOwnedNFTs().call({\n    from: from\n  }); //alert(ownedNFTS);\n\n  return ownedNFTS;\n}\nexport async function tokenURI(tokenID, from) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract; //alert(from)\n\n  let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n  let ownedNFTS = await vNFTABI.methods.tokenURI(tokenID).call({\n    from: from\n  }); //alert(ownedNFTS);\n\n  return ownedNFTS;\n} //\n// export async function isApprovedForAll(owner, operator) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.isApprovedForAll(owner, operator).call();\n// }\n// export async function safeTransferFrom(from, to, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.safeTransferFrom(from, to, tokenId).send({from: from});\n// }\n//\n// export async function burn(from, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.burn(tokenId).send({from: from, signatureType: biconomy.EIP712_SIGN});\n// }","map":{"version":3,"sources":["/Users/blakehatch/WebstormProjects/1st-edition-mint/src/smartContracts/Viridian1EPassMethods.js"],"names":["config","vGPJSON","Biconomy","Web3","web3Wallet","givenProvider","providers","HttpProvider","web3WS","WebsocketProvider","biconomy","apiKey","debug","biconomyWeb3","mint","from","numMint","setSuccess","setFailed","setMinting","vNFTContractAddress","rinkeby_contract_addresses","vgp_contract","vNFTABI","eth","Contract","methods","send","value","toString","vNFTABIWS","events","Transfer","filter","on","event","e","console","error","openPack","tokenId","signatureType","EIP712_SIGN","totalSupply","call","getOwnedNFTs","ownedNFTS","tokenURI","tokenID"],"mappings":"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","sourcesContent":["import config from \"../local-dev-config\";\nimport vGPJSON from \"../abis/ViridianGenesisPack.json\";\nimport {Biconomy} from \"@biconomy/mexa\";\nimport Web3 from \"web3\";\n\nlet web3Wallet = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n\nlet web3WS = new Web3(new Web3.providers.WebsocketProvider( \"wss://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n\nconst biconomy = new Biconomy(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"),{apiKey: \"TVCsgQVfk.a6031565-1cb6-40da-8a60-2ffec22e3bed\", debug: true});\n\nlet biconomyWeb3 = new Web3(biconomy);\n\n// biconomy.onEvent(biconomy.READY, () => {\n//     // Initialize your dapp here like getting user accounts etc\n//     console.log(\"initialized\");\n// }).onEvent(biconomy.ERROR, (error, message) => {\n//     // Handle error while initializing mexa\n//     console.error(error);\n// });\n\n// export async function tokenURI(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS: \" + tokenId);\n//     let nft = vNFTABI.methods.tokenURI(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return nft;\n// }\n//\n// export async function ownerOf(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS1: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function ownerOfNoReq(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS2: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function setApprovalForAll(from, exchangeAddress) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.setApprovalForAll(exchangeAddress, true).send({from: from});\n// }\n\nexport async function mint(from, numMint, setSuccess, setFailed, setMinting) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //alert((100000000000000000 * numMint).toString());\n    try {\n        await vNFTABI.methods.mint(numMint, from).send({\n            from: from, value: (100000000000000000 * numMint).toString(),\n            //signatureType: biconomy.EIP712_SIGN\n        });\n\n        let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n\n        await vNFTABIWS.events.Transfer({filter: {from: from}}).on('data', async function (event) {\n            setSuccess(true);\n            setFailed(false);\n            setMinting(false);\n        }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n\n    } catch(e) {\n        setFailed(true);\n        setMinting(false);\n        console.error(e);\n    }\n}\n\nexport async function openPack(from, tokenId, setSuccess, setFailed, setMinting) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    //alert((100000000000000000 * numMint).toString());\n    try {\n        await vNFTABI.methods.openPack(tokenId).send({\n            from: from,\n            signatureType: biconomy.EIP712_SIGN\n        });\n\n        let vNFTABIWS = new web3WS.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n\n        await vNFTABIWS.events.Transfer({filter: {from: from}}).on('data', async function (event) {\n            setSuccess(true);\n            setFailed(false);\n            setMinting(false);\n        }).on('err', (e) => {console.error(e); setFailed(true); setMinting(false);});\n\n    } catch(e) {\n        setFailed(true);\n        setMinting(false);\n        console.error(e);\n    }\n}\n\n// export async function bridge(from, bridgeNFTs) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n//\n//     let vNFTABI = new biconomyWeb3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.bridge(bridgeNFTs).send({from: from});\n// }\n\nexport async function totalSupply(from) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    return await vNFTABI.methods.totalSupply().call();\n    //return await vNFTABI.methods.getNumNFTs().call();\n}\n\nexport async function getOwnedNFTs(from) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n    //alert(from)\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    let ownedNFTS = await vNFTABI.methods.getOwnedNFTs().call({from: from});\n    //alert(ownedNFTS);\n    return ownedNFTS;\n}\n\nexport async function tokenURI(tokenID, from) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.vgp_contract;\n    //alert(from)\n    let vNFTABI = new web3Wallet.eth.Contract(vGPJSON['abi'], vNFTContractAddress);\n    let ownedNFTS = await vNFTABI.methods.tokenURI(tokenID).call({from: from});\n    //alert(ownedNFTS);\n    return ownedNFTS;\n}\n\n//\n// export async function isApprovedForAll(owner, operator) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.isApprovedForAll(owner, operator).call();\n// }\n\n// export async function safeTransferFrom(from, to, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.safeTransferFrom(from, to, tokenId).send({from: from});\n// }\n//\n// export async function burn(from, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.burn(tokenId).send({from: from, signatureType: biconomy.EIP712_SIGN});\n// }"]},"metadata":{},"sourceType":"module"}