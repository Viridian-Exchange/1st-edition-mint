{"ast":null,"code":"/*******************************************\n * THIS IS THE EIP-712 SIGN IMPLEMENTATION *\n *******************************************/\nimport config from \"../local-dev-config\";\nimport vTJSON from \"../abis/MetaTransactionTokenABI.json\";\nimport Web3 from \"web3\";\nimport { Biconomy } from \"@biconomy/mexa\"; //let web3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\") || \"HTTP://127.0.0.1:7545\");\n\nlet walletWeb3 = new Web3(Web3.givenProvider || Web3.providers.HttpProvider(\"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\nconst biconomy = new Biconomy(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"), {\n  apiKey: \"TVCsgQVfk.a6031565-1cb6-40da-8a60-2ffec22e3bed\",\n  debug: true\n}); // let biconomyWeb3 = new Web3(biconomy);\n// biconomy.onEvent(biconomy.READY, () => {\n//     // Initialize your dapp here like getting user accounts etc\n//     //alert(\"initialized\");\n// }).onEvent(biconomy.ERROR, (error, message) => {\n//     // Handle error while initializing mexa\n//     //alert(error);\n// });\n\nconst getSignatureParameters = signature => {\n  if (!walletWeb3.utils.isHexStrict(signature)) {\n    throw new Error('Given value \"'.concat(signature, '\" is not a valid hex string.'));\n  }\n\n  var r = signature.slice(0, 66);\n  var s = \"0x\".concat(signature.slice(66, 130));\n  var v = \"0x\".concat(signature.slice(130, 132));\n  v = walletWeb3.utils.hexToNumber(v);\n  if (![27, 28].includes(v)) v += 27;\n  return {\n    r: r,\n    s: s,\n    v: v\n  };\n};\n\nexport async function approve(fromAddr, exchangeAddress) {\n  const vTContractAddress = config.rinkeby_contract_addresses.vtContract; //let contract = new web3.eth.Contract(vTJSON, vTContractAddress);\n\n  let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n  //let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n  // This web3 instance is used to get user signature from connected wallet\n  //let walletWeb3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\"));\n  // Initialize constants\n\n  const domainType = [{\n    name: \"name\",\n    type: \"string\"\n  }, {\n    name: \"version\",\n    type: \"string\"\n  }, {\n    name: \"verifyingContract\",\n    type: \"address\"\n  }, {\n    name: \"salt\",\n    type: \"bytes32\"\n  }];\n  const metaTransactionType = [{\n    name: \"nonce\",\n    type: \"uint256\"\n  }, {\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"functionSignature\",\n    type: \"bytes\"\n  }]; // replace the chainId 42 if network is not kovan\n  // TODO: Make sure replacing verifyingContract with the WETH contract is correct\n\n  let domainData = {\n    name: \"Wrapped Ether\",\n    version: \"1\",\n    verifyingContract: vTContractAddress,\n    // converts Number to bytes32. Use your chainId instead of 42 if network is not Kovan\n    // TODO: Make sure this is correct\n    salt: '0x' + 137 .toString(16).padStart(64, '0')\n  };\n  let contract = new walletWeb3.eth.Contract(vTJSON, vTContractAddress);\n  let nonce = await contract.methods.getNonce(fromAddr).call(); // Create your target method signature.. here we are calling setQuote() method of our contract\n\n  let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n  let message = {};\n  message.nonce = parseInt(nonce);\n  message.from = fromAddr;\n  message.functionSignature = functionSignature;\n  const dataToSign = JSON.stringify({\n    types: {\n      EIP712Domain: domainType,\n      MetaTransaction: metaTransactionType\n    },\n    domain: domainData,\n    primaryType: \"MetaTransaction\",\n    message: message\n  }); // NOTE: Using walletWeb3 here, as it is connected to the wallet where user account is present.\n  // Get the EIP-712 Signature and send the transaction\n\n  walletWeb3.currentProvider.send({\n    jsonrpc: \"2.0\",\n    id: 999999999999,\n    method: \"eth_signTypedData_v4\",\n    params: [fromAddr, dataToSign]\n  }, function (error, response) {\n    // Check github repository for getSignatureParameters helper method\n    let {\n      r,\n      s,\n      v\n    } = getSignatureParameters(response.result);\n    let tx = contract.methods.executeMetaTransaction(fromAddr, functionSignature, r, s, v).send({\n      from: fromAddr\n    });\n    tx.on(\"transactionHash\", function (hash) {// Handle transaction hash\n    }).once(\"confirmation\", function (confirmationNumber, receipt) {\n      // Handle confirmation\n      alert(confirmationNumber);\n    }).on(\"error\", function (error) {\n      // Handle error\n      alert(\"ERROR: \" + JSON.stringify(error));\n    });\n  });\n}\nexport async function tokenAllowance(from, exchangeAddress) {\n  //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n  const vTContractAddress = config.rinkeby_contract_addresses.vt_contract;\n  let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress); //TODO: Figure out why from is wrong\n  //alert(from);\n  //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n  //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n\n  let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n  //alert(from + \" \" + exchangeAddress)\n\n  let tx = await vTABI.methods.allowance(from, exchangeAddress).call();\n  alert(tx); // await tx.on(\"transactionHash\", function (hash) {\n  //     console.log(`Transaction hash is ${hash}`);\n  //     alert(`Transaction sent. Waiting for confirmation ..`);\n  // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n  //     console.log(receipt);\n  //     console.log(receipt.transactionHash);\n  //     //do something with transaction hash\n  // });\n\n  await console.log(JSON.stringify(tx));\n  return tx; //await console.log(JSON.stringify(tx))\n}\nexport async function balanceOf(from) {\n  //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n  const vTContractAddress = config.rinkeby_contract_addresses.vt_contract;\n  let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress); //TODO: Figure out why from is wrong\n\n  let tx = await vTABI.methods.balanceOf(from).call(); // await tx.on(\"transactionHash\", function (hash) {\n  //     console.log(`Transaction hash is ${hash}`);\n  //     alert(`Transaction sent. Waiting for confirmation ..`);\n  // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n  //     console.log(receipt);\n  //     console.log(receipt.transactionHash);\n  //     //do something with transaction hash\n  // });\n\n  await console.log(JSON.stringify(tx));\n  return tx; //await console.log(JSON.stringify(tx))\n}\n/**************************************\n * Original Non-Gassless Approve Call *\n **************************************/\n\nexport async function approveRegular(from, exchangeAddress) {\n  //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n  const vTContractAddress = config.rinkeby_contract_addresses.vt_contract;\n  let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress); //TODO: Figure out why from is wrong\n  //alert(from);\n  //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n  //alert(await vTABI.methods.allowance(from, '0xE88F4ae472687ce2026eb2d587C5C0c42a5F2047').call());\n\n  let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n\n  alert(from + \" \" + exchangeAddress);\n  let tx = await vTABI.methods.approve(exchangeAddress, infinite_approve_amount).send({\n    from: from,\n    signatureType: biconomy.EIP712_SIGN\n  }); // await tx.on(\"transactionHash\", function (hash) {\n  //     console.log(`Transaction hash is ${hash}`);\n  //     alert(`Transaction sent. Waiting for confirmation ..`);\n  // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n  //     console.log(receipt);\n  //     console.log(receipt.transactionHash);\n  //     //do something with transaction hash\n  // });\n\n  await console.log(JSON.stringify(tx));\n  return tx; //await console.log(JSON.stringify(tx))\n}","map":{"version":3,"sources":["/Users/blakehatch/WebstormProjects/1st-edition-mint/src/smartContracts/ViridianTokenMethods.js"],"names":["config","vTJSON","Web3","Biconomy","walletWeb3","givenProvider","providers","HttpProvider","biconomy","apiKey","debug","getSignatureParameters","signature","utils","isHexStrict","Error","concat","r","slice","s","v","hexToNumber","includes","approve","fromAddr","exchangeAddress","vTContractAddress","rinkeby_contract_addresses","vtContract","infinite_approve_amount","domainType","name","type","metaTransactionType","domainData","version","verifyingContract","salt","toString","padStart","contract","eth","Contract","nonce","methods","getNonce","call","functionSignature","encodeABI","message","parseInt","from","dataToSign","JSON","stringify","types","EIP712Domain","MetaTransaction","domain","primaryType","currentProvider","send","jsonrpc","id","method","params","error","response","result","tx","executeMetaTransaction","on","hash","once","confirmationNumber","receipt","alert","tokenAllowance","vt_contract","vTABI","allowance","console","log","balanceOf","approveRegular","signatureType","EIP712_SIGN"],"mappings":"AAAA;AACA;AACA;AAEA,OAAOA,MAAP,MAAmB,qBAAnB;AACA,OAAOC,MAAP,MAAmB,sCAAnB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,SAAQC,QAAR,QAAuB,gBAAvB,C,CACA;;AACA,IAAIC,UAAU,GAAG,IAAIF,IAAJ,CAASA,IAAI,CAACG,aAAL,IAAsBH,IAAI,CAACI,SAAL,CAAeC,YAAf,CAA6B,uEAA7B,CAA/B,CAAjB;AAEA,MAAMC,QAAQ,GAAG,IAAIL,QAAJ,CAAaD,IAAI,CAACG,aAAL,IAAsB,IAAIH,IAAI,CAACI,SAAL,CAAeC,YAAnB,CAAiC,uEAAjC,CAAnC,EAA6I;AAACE,EAAAA,MAAM,EAAE,gDAAT;AAA2DC,EAAAA,KAAK,EAAE;AAAlE,CAA7I,CAAjB,C,CAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,sBAAsB,GAAGC,SAAS,IAAI;AACxC,MAAI,CAACR,UAAU,CAACS,KAAX,CAAiBC,WAAjB,CAA6BF,SAA7B,CAAL,EAA8C;AAC1C,UAAM,IAAIG,KAAJ,CACF,gBAAgBC,MAAhB,CAAuBJ,SAAvB,EAAkC,8BAAlC,CADE,CAAN;AAGH;;AACD,MAAIK,CAAC,GAAGL,SAAS,CAACM,KAAV,CAAgB,CAAhB,EAAmB,EAAnB,CAAR;AACA,MAAIC,CAAC,GAAG,KAAKH,MAAL,CAAYJ,SAAS,CAACM,KAAV,CAAgB,EAAhB,EAAoB,GAApB,CAAZ,CAAR;AACA,MAAIE,CAAC,GAAG,KAAKJ,MAAL,CAAYJ,SAAS,CAACM,KAAV,CAAgB,GAAhB,EAAqB,GAArB,CAAZ,CAAR;AACAE,EAAAA,CAAC,GAAGhB,UAAU,CAACS,KAAX,CAAiBQ,WAAjB,CAA6BD,CAA7B,CAAJ;AACA,MAAI,CAAC,CAAC,EAAD,EAAK,EAAL,EAASE,QAAT,CAAkBF,CAAlB,CAAL,EAA2BA,CAAC,IAAI,EAAL;AAC3B,SAAO;AACHH,IAAAA,CAAC,EAAEA,CADA;AAEHE,IAAAA,CAAC,EAAEA,CAFA;AAGHC,IAAAA,CAAC,EAAEA;AAHA,GAAP;AAKH,CAhBD;;AAkBA,OAAO,eAAeG,OAAf,CAAuBC,QAAvB,EAAiCC,eAAjC,EAAkD;AACrD,QAAMC,iBAAiB,GAAG1B,MAAM,CAAC2B,0BAAP,CAAkCC,UAA5D,CADqD,CAGrD;;AAEA,MAAIC,uBAAuB,GAAG,gFAA9B,CALqD,CAK2D;AAEhH;AAEA;AACA;AAEA;;AACA,QAAMC,UAAU,GAAG,CACf;AAAEC,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,IAAI,EAAE;AAAtB,GADe,EAEf;AAAED,IAAAA,IAAI,EAAE,SAAR;AAAmBC,IAAAA,IAAI,EAAE;AAAzB,GAFe,EAGf;AAAED,IAAAA,IAAI,EAAE,mBAAR;AAA6BC,IAAAA,IAAI,EAAE;AAAnC,GAHe,EAIf;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,IAAI,EAAE;AAAtB,GAJe,CAAnB;AAMA,QAAMC,mBAAmB,GAAG,CACxB;AAAEF,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE;AAAvB,GADwB,EAExB;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,IAAI,EAAE;AAAtB,GAFwB,EAGxB;AAAED,IAAAA,IAAI,EAAE,mBAAR;AAA6BC,IAAAA,IAAI,EAAE;AAAnC,GAHwB,CAA5B,CAnBqD,CAwBzD;AACI;;AACA,MAAIE,UAAU,GAAG;AACbH,IAAAA,IAAI,EAAE,eADO;AAEbI,IAAAA,OAAO,EAAE,GAFI;AAGbC,IAAAA,iBAAiB,EAAEV,iBAHN;AAIb;AACA;AACAW,IAAAA,IAAI,EAAE,OAAQ,GAAD,EAAMC,QAAN,CAAe,EAAf,EAAmBC,QAAnB,CAA4B,EAA5B,EAAgC,GAAhC;AANA,GAAjB;AAUI,MAAIC,QAAQ,GAAG,IAAIpC,UAAU,CAACqC,GAAX,CAAeC,QAAnB,CACXzC,MADW,EAEXyB,iBAFW,CAAf;AAIY,MAAIiB,KAAK,GAAG,MAAMH,QAAQ,CAACI,OAAT,CAAiBC,QAAjB,CAA0BrB,QAA1B,EAAoCsB,IAApC,EAAlB,CAxCqC,CAyCrC;;AACA,MAAIC,iBAAiB,GAAGP,QAAQ,CAACI,OAAT,CAAiBrB,OAAjB,CAAyBE,eAAzB,EAA0CI,uBAA1C,EAAmEmB,SAAnE,EAAxB;AACA,MAAIC,OAAO,GAAG,EAAd;AACAA,EAAAA,OAAO,CAACN,KAAR,GAAgBO,QAAQ,CAACP,KAAD,CAAxB;AACAM,EAAAA,OAAO,CAACE,IAAR,GAAe3B,QAAf;AACAyB,EAAAA,OAAO,CAACF,iBAAR,GAA4BA,iBAA5B;AAEA,QAAMK,UAAU,GAAGC,IAAI,CAACC,SAAL,CAAe;AAClCC,IAAAA,KAAK,EAAE;AACPC,MAAAA,YAAY,EAAE1B,UADP;AAEP2B,MAAAA,eAAe,EAAExB;AAFV,KAD2B;AAKlCyB,IAAAA,MAAM,EAAExB,UAL0B;AAMlCyB,IAAAA,WAAW,EAAE,iBANqB;AAOlCV,IAAAA,OAAO,EAAEA;AAPyB,GAAf,CAAnB,CAhDqC,CA0DrC;AACA;;AACA7C,EAAAA,UAAU,CAACwD,eAAX,CAA2BC,IAA3B,CAAgC;AAChCC,IAAAA,OAAO,EAAE,KADuB;AAEhCC,IAAAA,EAAE,EAAE,YAF4B;AAGhCC,IAAAA,MAAM,EAAE,sBAHwB;AAIhCC,IAAAA,MAAM,EAAE,CAACzC,QAAD,EAAW4B,UAAX;AAJwB,GAAhC,EAKF,UAASc,KAAT,EAAgBC,QAAhB,EAA0B;AACxB;AACA,QAAI;AAAElD,MAAAA,CAAF;AAAKE,MAAAA,CAAL;AAAQC,MAAAA;AAAR,QAAcT,sBAAsB,CAACwD,QAAQ,CAACC,MAAV,CAAxC;AAEA,QAAIC,EAAE,GAAG7B,QAAQ,CAACI,OAAT,CAAiB0B,sBAAjB,CAAwC9C,QAAxC,EACTuB,iBADS,EACU9B,CADV,EACaE,CADb,EACgBC,CADhB,EAERyC,IAFQ,CAEH;AAACV,MAAAA,IAAI,EAAE3B;AAAP,KAFG,CAAT;AAIA6C,IAAAA,EAAE,CAACE,EAAH,CAAM,iBAAN,EAAyB,UAASC,IAAT,EAAe,CACxC;AACH,KAFG,EAEDC,IAFC,CAEI,cAFJ,EAEoB,UAASC,kBAAT,EAA6BC,OAA7B,EAAsC;AAC1D;AACIC,MAAAA,KAAK,CAACF,kBAAD,CAAL;AACP,KALG,EAKDH,EALC,CAKE,OALF,EAKW,UAASL,KAAT,EAAgB;AAC3B;AACIU,MAAAA,KAAK,CAAC,YAAYvB,IAAI,CAACC,SAAL,CAAeY,KAAf,CAAb,CAAL;AACP,KARG;AAUH,GAvBG;AAyBnB;AAED,OAAO,eAAeW,cAAf,CAA8B1B,IAA9B,EAAoC1B,eAApC,EAAqD;AACxD;AAEA,QAAMC,iBAAiB,GAAG1B,MAAM,CAAC2B,0BAAP,CAAkCmD,WAA5D;AAEA,MAAIC,KAAK,GAAG,IAAI3E,UAAU,CAACqC,GAAX,CAAeC,QAAnB,CAA4BzC,MAA5B,EAAoCyB,iBAApC,CAAZ,CALwD,CAQxD;AACA;AAEA;AACA;;AAEA,MAAIG,uBAAuB,GAAG,gFAA9B,CAdwD,CAcwD;AAEhH;;AACA,MAAIwC,EAAE,GAAG,MAAMU,KAAK,CAACnC,OAAN,CAAcoC,SAAd,CAAwB7B,IAAxB,EAA8B1B,eAA9B,EAA+CqB,IAA/C,EAAf;AACA8B,EAAAA,KAAK,CAACP,EAAD,CAAL,CAlBwD,CAoBxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAMY,OAAO,CAACC,GAAR,CAAY7B,IAAI,CAACC,SAAL,CAAee,EAAf,CAAZ,CAAN;AAEA,SAAOA,EAAP,CA/BwD,CAgCxD;AACH;AAED,OAAO,eAAec,SAAf,CAAyBhC,IAAzB,EAA+B;AAClC;AAEA,QAAMzB,iBAAiB,GAAG1B,MAAM,CAAC2B,0BAAP,CAAkCmD,WAA5D;AAEA,MAAIC,KAAK,GAAG,IAAI3E,UAAU,CAACqC,GAAX,CAAeC,QAAnB,CAA4BzC,MAA5B,EAAoCyB,iBAApC,CAAZ,CALkC,CAQlC;;AAEA,MAAI2C,EAAE,GAAG,MAAMU,KAAK,CAACnC,OAAN,CAAcuC,SAAd,CAAwBhC,IAAxB,EAA8BL,IAA9B,EAAf,CAVkC,CAYlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAMmC,OAAO,CAACC,GAAR,CAAY7B,IAAI,CAACC,SAAL,CAAee,EAAf,CAAZ,CAAN;AAEA,SAAOA,EAAP,CAvBkC,CAwBlC;AACH;AAED;AACA;AACA;;AAEA,OAAO,eAAee,cAAf,CAA8BjC,IAA9B,EAAoC1B,eAApC,EAAqD;AACxD;AAEA,QAAMC,iBAAiB,GAAG1B,MAAM,CAAC2B,0BAAP,CAAkCmD,WAA5D;AAEA,MAAIC,KAAK,GAAG,IAAI3E,UAAU,CAACqC,GAAX,CAAeC,QAAnB,CAA4BzC,MAA5B,EAAoCyB,iBAApC,CAAZ,CALwD,CAOxD;AACA;AAEA;AACA;;AAEA,MAAIG,uBAAuB,GAAG,gFAA9B,CAbwD,CAawD;;AAEhH+C,EAAAA,KAAK,CAACzB,IAAI,GAAG,GAAP,GAAa1B,eAAd,CAAL;AACA,MAAI4C,EAAE,GAAG,MAAMU,KAAK,CAACnC,OAAN,CAAcrB,OAAd,CAAsBE,eAAtB,EAAuCI,uBAAvC,EAAgEgC,IAAhE,CAAqE;AAACV,IAAAA,IAAI,EAAEA,IAAP;AAAakC,IAAAA,aAAa,EAAE7E,QAAQ,CAAC8E;AAArC,GAArE,CAAf,CAhBwD,CAkBxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAML,OAAO,CAACC,GAAR,CAAY7B,IAAI,CAACC,SAAL,CAAee,EAAf,CAAZ,CAAN;AAEA,SAAOA,EAAP,CA7BwD,CA8BxD;AACH","sourcesContent":["/*******************************************\n * THIS IS THE EIP-712 SIGN IMPLEMENTATION *\n *******************************************/\n\nimport config from \"../local-dev-config\";\nimport vTJSON from \"../abis/MetaTransactionTokenABI.json\";\nimport Web3 from \"web3\";\nimport {Biconomy} from \"@biconomy/mexa\";\n//let web3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\") || \"HTTP://127.0.0.1:7545\");\nlet walletWeb3 = new Web3(Web3.givenProvider || Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n\nconst biconomy = new Biconomy(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"),{apiKey: \"TVCsgQVfk.a6031565-1cb6-40da-8a60-2ffec22e3bed\", debug: true});\n\n// let biconomyWeb3 = new Web3(biconomy);\n\n// biconomy.onEvent(biconomy.READY, () => {\n//     // Initialize your dapp here like getting user accounts etc\n//     //alert(\"initialized\");\n// }).onEvent(biconomy.ERROR, (error, message) => {\n//     // Handle error while initializing mexa\n//     //alert(error);\n// });\n\nconst getSignatureParameters = signature => {\n    if (!walletWeb3.utils.isHexStrict(signature)) {\n        throw new Error(\n            'Given value \"'.concat(signature, '\" is not a valid hex string.')\n        );\n    }\n    var r = signature.slice(0, 66);\n    var s = \"0x\".concat(signature.slice(66, 130));\n    var v = \"0x\".concat(signature.slice(130, 132));\n    v = walletWeb3.utils.hexToNumber(v);\n    if (![27, 28].includes(v)) v += 27;\n    return {\n        r: r,\n        s: s,\n        v: v\n    };\n};\n\nexport async function approve(fromAddr, exchangeAddress) {\n    const vTContractAddress = config.rinkeby_contract_addresses.vtContract;\n\n    //let contract = new web3.eth.Contract(vTJSON, vTContractAddress);\n\n    let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n\n    //let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n\n    // This web3 instance is used to get user signature from connected wallet\n    //let walletWeb3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\"));\n\n    // Initialize constants\n    const domainType = [\n        { name: \"name\", type: \"string\" },\n        { name: \"version\", type: \"string\" },\n        { name: \"verifyingContract\", type: \"address\" },\n        { name: \"salt\", type: \"bytes32\" },\n    ];\n    const metaTransactionType = [\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"from\", type: \"address\" },\n        { name: \"functionSignature\", type: \"bytes\" }\n    ];\n// replace the chainId 42 if network is not kovan\n    // TODO: Make sure replacing verifyingContract with the WETH contract is correct\n    let domainData = {\n        name: \"Wrapped Ether\",\n        version: \"1\",\n        verifyingContract: vTContractAddress,\n        // converts Number to bytes32. Use your chainId instead of 42 if network is not Kovan\n        // TODO: Make sure this is correct\n        salt: '0x' + (137).toString(16).padStart(64, '0')\n    };\n\n\n        let contract = new walletWeb3.eth.Contract(\n            vTJSON,\n            vTContractAddress);\n\n                    let nonce = await contract.methods.getNonce(fromAddr).call();\n                    // Create your target method signature.. here we are calling setQuote() method of our contract\n                    let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n                    let message = {};\n                    message.nonce = parseInt(nonce);\n                    message.from = fromAddr;\n                    message.functionSignature = functionSignature;\n\n                    const dataToSign = JSON.stringify({\n                    types: {\n                    EIP712Domain: domainType,\n                    MetaTransaction: metaTransactionType\n                },\n                    domain: domainData,\n                    primaryType: \"MetaTransaction\",\n                    message: message\n                });\n\n                    // NOTE: Using walletWeb3 here, as it is connected to the wallet where user account is present.\n                    // Get the EIP-712 Signature and send the transaction\n                    walletWeb3.currentProvider.send({\n                    jsonrpc: \"2.0\",\n                    id: 999999999999,\n                    method: \"eth_signTypedData_v4\",\n                    params: [fromAddr, dataToSign]\n                },function(error, response) {\n                    // Check github repository for getSignatureParameters helper method\n                    let { r, s, v } = getSignatureParameters(response.result);\n\n                    let tx = contract.methods.executeMetaTransaction(fromAddr,\n                    functionSignature, r, s, v)\n                    .send({from: fromAddr});\n\n                    tx.on(\"transactionHash\", function(hash) {\n                    // Handle transaction hash\n                }).once(\"confirmation\", function(confirmationNumber, receipt) {\n                    // Handle confirmation\n                        alert(confirmationNumber);\n                }).on(\"error\", function(error) {\n                    // Handle error\n                        alert(\"ERROR: \" + JSON.stringify(error));\n                });\n\n                }\n                    );\n}\n\nexport async function tokenAllowance(from, exchangeAddress) {\n    //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n\n    const vTContractAddress = config.rinkeby_contract_addresses.vt_contract;\n\n    let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress);\n\n\n    //TODO: Figure out why from is wrong\n    //alert(from);\n\n    //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n    //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n\n    let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n\n    //alert(from + \" \" + exchangeAddress)\n    let tx = await vTABI.methods.allowance(from, exchangeAddress).call();\n    alert(tx);\n\n    // await tx.on(\"transactionHash\", function (hash) {\n    //     console.log(`Transaction hash is ${hash}`);\n    //     alert(`Transaction sent. Waiting for confirmation ..`);\n    // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n    //     console.log(receipt);\n    //     console.log(receipt.transactionHash);\n    //     //do something with transaction hash\n    // });\n\n    await console.log(JSON.stringify(tx))\n\n    return tx;\n    //await console.log(JSON.stringify(tx))\n}\n\nexport async function balanceOf(from) {\n    //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n\n    const vTContractAddress = config.rinkeby_contract_addresses.vt_contract;\n\n    let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress);\n\n\n    //TODO: Figure out why from is wrong\n\n    let tx = await vTABI.methods.balanceOf(from).call();\n\n    // await tx.on(\"transactionHash\", function (hash) {\n    //     console.log(`Transaction hash is ${hash}`);\n    //     alert(`Transaction sent. Waiting for confirmation ..`);\n    // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n    //     console.log(receipt);\n    //     console.log(receipt.transactionHash);\n    //     //do something with transaction hash\n    // });\n\n    await console.log(JSON.stringify(tx))\n\n    return tx;\n    //await console.log(JSON.stringify(tx))\n}\n\n/**************************************\n * Original Non-Gassless Approve Call *\n **************************************/\n\nexport async function approveRegular(from, exchangeAddress) {\n    //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n\n    const vTContractAddress = config.rinkeby_contract_addresses.vt_contract;\n\n    let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress);\n\n    //TODO: Figure out why from is wrong\n    //alert(from);\n\n    //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n    //alert(await vTABI.methods.allowance(from, '0xE88F4ae472687ce2026eb2d587C5C0c42a5F2047').call());\n\n    let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n    \n    alert(from + \" \" + exchangeAddress);\n    let tx = await vTABI.methods.approve(exchangeAddress, infinite_approve_amount).send({from: from, signatureType: biconomy.EIP712_SIGN});\n\n    // await tx.on(\"transactionHash\", function (hash) {\n    //     console.log(`Transaction hash is ${hash}`);\n    //     alert(`Transaction sent. Waiting for confirmation ..`);\n    // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n    //     console.log(receipt);\n    //     console.log(receipt.transactionHash);\n    //     //do something with transaction hash\n    // });\n\n    await console.log(JSON.stringify(tx))\n\n    return tx;\n    //await console.log(JSON.stringify(tx))\n}"]},"metadata":{},"sourceType":"module"}