{"ast":null,"code":"import config from \"../local-dev-config\";\nimport vNFTJSON from \"../abis/Viridian1EPass.json\";\nimport Web3 from \"web3\";\nlet web3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\")); // export async function tokenURI(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS: \" + tokenId);\n//     let nft = vNFTABI.methods.tokenURI(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return nft;\n// }\n//\n// export async function ownerOf(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS1: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function ownerOfNoReq(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS2: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function setApprovalForAll(from, exchangeAddress) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.setApprovalForAll(exchangeAddress, true).send({from: from});\n// }\n\nexport async function mint(from, numMint) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n  let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n  return await vNFTABI.methods.mint(numMint).send({\n    from: from,\n    value: (1000000000000000000 * numMint).toString()\n  });\n}\nexport async function bridge(from, bridgeNFTs) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n  let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n  return await vNFTABI.methods.bridge(bridgeNFTs).send({\n    from: from\n  });\n}\nexport async function getNumNFTs(from) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n  let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress); //return await vNFTABI.methods.totalSupply().call();\n\n  return await vNFTABI.methods.getNumNFTs().call();\n}\nexport async function getOwnedNFTs(from) {\n  //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n  const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract; //alert(from)\n\n  let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n  let ownedNFTS = await vNFTABI.methods.getOwnedNFTs().call({\n    from: from\n  }); //alert(ownedNFTS);\n\n  return ownedNFTS;\n} //\n// export async function isApprovedForAll(owner, operator) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.isApprovedForAll(owner, operator).call();\n// }\n// export async function safeTransferFrom(from, to, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.safeTransferFrom(from, to, tokenId).send({from: from});\n// }\n//\n// export async function burn(from, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.burn(tokenId).send({from: from, signatureType: biconomy.EIP712_SIGN});\n// }","map":{"version":3,"sources":["/Users/blakehatch/WebstormProjects/1st-edition-mint/src/smartContracts/Viridian1EPassMethods.js"],"names":["config","vNFTJSON","Web3","web3","givenProvider","providers","HttpProvider","mint","from","numMint","vNFTContractAddress","rinkeby_contract_addresses","v1ep_contract","vNFTABI","eth","Contract","methods","send","value","toString","bridge","bridgeNFTs","getNumNFTs","call","getOwnedNFTs","ownedNFTS"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,qBAAnB;AACA,OAAOC,QAAP,MAAqB,6BAArB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AAEA,IAAIC,IAAI,GAAG,IAAID,IAAJ,CAASA,IAAI,CAACE,aAAL,IAAsB,IAAIF,IAAI,CAACG,SAAL,CAAeC,YAAnB,CAAiC,uEAAjC,CAA/B,CAAX,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAeC,IAAf,CAAoBC,IAApB,EAA0BC,OAA1B,EAAmC;AACtC;AACA,QAAMC,mBAAmB,GAAGV,MAAM,CAACW,0BAAP,CAAkCC,aAA9D;AAEA,MAAIC,OAAO,GAAG,IAAIV,IAAI,CAACW,GAAL,CAASC,QAAb,CAAsBd,QAAQ,CAAC,KAAD,CAA9B,EAAuCS,mBAAvC,CAAd;AACA,SAAO,MAAMG,OAAO,CAACG,OAAR,CAAgBT,IAAhB,CAAqBE,OAArB,EAA8BQ,IAA9B,CAAmC;AAACT,IAAAA,IAAI,EAAEA,IAAP;AAAaU,IAAAA,KAAK,EAAE,CAAC,sBAAsBT,OAAvB,EAAgCU,QAAhC;AAApB,GAAnC,CAAb;AACH;AAED,OAAO,eAAeC,MAAf,CAAsBZ,IAAtB,EAA4Ba,UAA5B,EAAwC;AAC3C;AACA,QAAMX,mBAAmB,GAAGV,MAAM,CAACW,0BAAP,CAAkCC,aAA9D;AAEA,MAAIC,OAAO,GAAG,IAAIV,IAAI,CAACW,GAAL,CAASC,QAAb,CAAsBd,QAAQ,CAAC,KAAD,CAA9B,EAAuCS,mBAAvC,CAAd;AACA,SAAO,MAAMG,OAAO,CAACG,OAAR,CAAgBI,MAAhB,CAAuBC,UAAvB,EAAmCJ,IAAnC,CAAwC;AAACT,IAAAA,IAAI,EAAEA;AAAP,GAAxC,CAAb;AACH;AAED,OAAO,eAAec,UAAf,CAA0Bd,IAA1B,EAAgC;AACnC;AACA,QAAME,mBAAmB,GAAGV,MAAM,CAACW,0BAAP,CAAkCC,aAA9D;AAEA,MAAIC,OAAO,GAAG,IAAIV,IAAI,CAACW,GAAL,CAASC,QAAb,CAAsBd,QAAQ,CAAC,KAAD,CAA9B,EAAuCS,mBAAvC,CAAd,CAJmC,CAKnC;;AACA,SAAO,MAAMG,OAAO,CAACG,OAAR,CAAgBM,UAAhB,GAA6BC,IAA7B,EAAb;AACH;AAED,OAAO,eAAeC,YAAf,CAA4BhB,IAA5B,EAAkC;AACrC;AACA,QAAME,mBAAmB,GAAGV,MAAM,CAACW,0BAAP,CAAkCC,aAA9D,CAFqC,CAGrC;;AACA,MAAIC,OAAO,GAAG,IAAIV,IAAI,CAACW,GAAL,CAASC,QAAb,CAAsBd,QAAQ,CAAC,KAAD,CAA9B,EAAuCS,mBAAvC,CAAd;AACA,MAAIe,SAAS,GAAG,MAAMZ,OAAO,CAACG,OAAR,CAAgBQ,YAAhB,GAA+BD,IAA/B,CAAoC;AAACf,IAAAA,IAAI,EAAEA;AAAP,GAApC,CAAtB,CALqC,CAMrC;;AACA,SAAOiB,SAAP;AACH,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import config from \"../local-dev-config\";\nimport vNFTJSON from \"../abis/Viridian1EPass.json\";\nimport Web3 from \"web3\";\n\nlet web3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://eth-rinkeby.alchemyapi.io/v2/LAxJKtplSWDfvNU0-v7K77WOeCWYb4Js\"));\n\n// export async function tokenURI(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS: \" + tokenId);\n//     let nft = vNFTABI.methods.tokenURI(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return nft;\n// }\n//\n// export async function ownerOf(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS1: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function ownerOfNoReq(tokenId) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     //console.log(\"ABIMETHODS2: \" + tokenId);\n//     let owner = await vNFTABI.methods.ownerOf(tokenId).call();\n//\n//     //alert(nft);\n//\n//     return owner;\n// }\n//\n// export async function setApprovalForAll(from, exchangeAddress) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//     return await vNFTABI.methods.setApprovalForAll(exchangeAddress, true).send({from: from});\n// }\n\nexport async function mint(from, numMint) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n\n    let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n    return await vNFTABI.methods.mint(numMint).send({from: from, value: (1000000000000000000 * numMint).toString()});\n}\n\nexport async function bridge(from, bridgeNFTs) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n\n    let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n    return await vNFTABI.methods.bridge(bridgeNFTs).send({from: from});\n}\n\nexport async function getNumNFTs(from) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n\n    let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n    //return await vNFTABI.methods.totalSupply().call();\n    return await vNFTABI.methods.getNumNFTs().call();\n}\n\nexport async function getOwnedNFTs(from) {\n    //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n    const vNFTContractAddress = config.rinkeby_contract_addresses.v1ep_contract;\n    //alert(from)\n    let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n    let ownedNFTS = await vNFTABI.methods.getOwnedNFTs().call({from: from});\n    //alert(ownedNFTS);\n    return ownedNFTS;\n}\n\n//\n// export async function isApprovedForAll(owner, operator) {\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.isApprovedForAll(owner, operator).call();\n// }\n\n// export async function safeTransferFrom(from, to, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.safeTransferFrom(from, to, tokenId).send({from: from});\n// }\n//\n// export async function burn(from, tokenId) {\n//     //alert(\"Setting approval to \" + from + \" for \" + exchangeAddress);\n//     const vNFTContractAddress = config.mumbai_contract_addresses.vnft_contract;\n//\n//     let vNFTABI = new web3.eth.Contract(vNFTJSON['abi'], vNFTContractAddress);\n//\n//     return await vNFTABI.methods.burn(tokenId).send({from: from, signatureType: biconomy.EIP712_SIGN});\n// }"]},"metadata":{},"sourceType":"module"}