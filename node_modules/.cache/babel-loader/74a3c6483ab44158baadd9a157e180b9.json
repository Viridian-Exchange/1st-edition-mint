{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport React, { useReducer, useEffect } from \"react\";\nimport { CryptoPriceReducer } from \"./CryptoPriceReducer\";\nimport CryptoPriceContext from \"./CryptoPriceContext\";\nimport axios from \"axios\";\nimport { COIN_CAP_WS_URI, COIN_CAP_URI } from \"./config\";\nimport { STREAM_PRICES, STREAM_TICKER, GET_ASSETS, INITIALIZED, CACHE_ASSETS } from \"./types\";\nexport default function CryptoPriceProvider(_a) {\n  var cryptoCompareApiKey = _a.cryptoCompareApiKey,\n      children = _a.children;\n  var initialState = {\n    assets: [],\n    prices: {},\n    tickers: {},\n    pricesWebSocket: null,\n    tickersWebSocket: null,\n    initialized: false,\n    assetCache: {}\n  };\n\n  var _b = __read(useReducer(CryptoPriceReducer, initialState), 2),\n      state = _b[0],\n      dispatch = _b[1];\n\n  useEffect(function () {\n    getAssets();\n  }, []);\n\n  var getAssets = function () {\n    axios(COIN_CAP_URI + \"assets?limit=1500\").then(function (res) {\n      dispatch({\n        type: GET_ASSETS,\n        payload: res.data.data\n      });\n      dispatch({\n        type: INITIALIZED,\n        payload: true\n      });\n    }).catch(function (err) {\n      return console.error(err);\n    });\n  };\n\n  var resolveAssetCache = function (assets, matchKey, cache) {\n    if (cache === void 0) {\n      cache = {};\n    }\n\n    var cachedSymbols = matchKey === \"id\" ? Object.keys(cache) : Object.values(cache);\n    var newAssets = assets.filter(function (asset) {\n      return !cachedSymbols.includes(asset);\n    });\n    var mappedSymbols = state.assets.filter(function (asset) {\n      return newAssets.includes(asset[matchKey]);\n    }).map(function (asset) {\n      return {\n        id: asset.id,\n        symbol: asset.symbol.toLowerCase()\n      };\n    });\n\n    var mapperCache = __assign({}, cache);\n\n    mappedSymbols.forEach(function (symMap) {\n      return mapperCache[symMap.id] = symMap.symbol;\n    });\n    return mapperCache;\n  };\n\n  var connectPrices = function (symbols) {\n    state.pricesWebSocket = new WebSocket(COIN_CAP_WS_URI + \"prices?assets=\" + symbols.join(\",\"));\n\n    state.pricesWebSocket.onclose = function (e) {\n      console.log(\"Price socket closed...reconnecting in 1 second.\", e.reason);\n      setTimeout(function () {\n        connectPrices(symbols);\n      }, 1000);\n    };\n\n    state.pricesWebSocket.onerror = function (err) {\n      console.error(\"Price socket encountered error: \", err.message, \"Closing socket\");\n      state.pricesWebSocket.close();\n    };\n\n    state.pricesWebSocket.onmessage = function (msg) {\n      var data = JSON.parse(msg.data);\n      var symbolIds = Object.keys(data);\n\n      if (state.assets.length > 0) {\n        var mapperCache_1 = resolveAssetCache(symbolIds, \"id\", state.assetCache);\n        var formattedPrices_1 = {};\n        symbolIds.forEach(function (symbolId) {\n          formattedPrices_1[mapperCache_1[symbolId]] = parseFloat(data[symbolId]);\n        });\n        dispatch({\n          type: CACHE_ASSETS,\n          payload: mapperCache_1\n        });\n        dispatch({\n          type: STREAM_PRICES,\n          payload: formattedPrices_1\n        });\n      }\n    };\n  };\n\n  var connectTickers = function (symbols) {\n    state.tickersWebSocket = new WebSocket(\"wss://streamer.cryptocompare.com/v2?apiKey=\" + cryptoCompareApiKey);\n\n    state.tickersWebSocket.onopen = function onStreamOpen() {\n      var subRequest = {\n        action: \"SubAdd\",\n        subs: symbols.map(function (symbol) {\n          return \"24~CCCAGG~\" + symbol.toUpperCase() + \"~USD~m\";\n        })\n      };\n      state.tickersWebSocket.send(JSON.stringify(subRequest));\n    };\n\n    state.tickersWebSocket.onclose = function (e) {\n      console.log(\"Ticker socket closed...reconnecting in 1 second.\", e.reason);\n      setTimeout(function () {\n        connectTickers(symbols);\n      }, 1000);\n    };\n\n    state.tickersWebSocket.onerror = function (err) {\n      console.error(\"Ticker socket encountered error: \", err.message, \"Closing socket\");\n      state.tickersWebSocket.close();\n    };\n\n    state.tickersWebSocket.onmessage = function (message) {\n      var _a, _b;\n\n      var data = JSON.parse(message.data);\n\n      if (data.TYPE === \"24\" && (data.ACTION === \"A\" || data.ACTION === \"I\")) {\n        var tickersCopy = state.tickers;\n        var symbol = data.FROMSYMBOL.toLowerCase();\n\n        if (Object.keys(tickersCopy).includes(symbol)) {\n          if (state.tickers[symbol].timestamp < new Date(data.TS * 1000)) {\n            var formattedTicker = {\n              timestamp: new Date(data.TS * 1000),\n              open: data.OPEN,\n              high: data.CLOSE,\n              low: data.LOW,\n              close: data.CLOSE,\n              volume: data.VOLUMETO\n            };\n            var payload = (_a = {}, _a[data.FROMSYMBOL.toLowerCase()] = formattedTicker, _a);\n            dispatch({\n              type: STREAM_TICKER,\n              payload: payload\n            });\n          }\n        } else {\n          var formattedTicker = {\n            timestamp: new Date(data.TS * 1000),\n            open: data.OPEN,\n            high: data.CLOSE,\n            low: data.LOW,\n            close: data.CLOSE,\n            volume: data.VOLUMETO\n          };\n          var payload = (_b = {}, _b[data.FROMSYMBOL.toLowerCase()] = formattedTicker, _b);\n          dispatch({\n            type: STREAM_TICKER,\n            payload: payload\n          });\n        }\n      }\n    };\n  };\n\n  var streamPrices = function (symbols) {\n    var symbolCache = resolveAssetCache(symbols.map(function (s) {\n      return s.toUpperCase();\n    }), \"symbol\");\n    dispatch({\n      type: CACHE_ASSETS,\n      payload: symbolCache\n    });\n    symbols = Object.keys(symbolCache);\n    connectPrices(symbols);\n  };\n\n  var streamTickers = function (symbols) {\n    if (cryptoCompareApiKey) {\n      connectTickers(symbols);\n    } else {\n      dispatch({\n        type: STREAM_TICKER,\n        payload: {\n          error: \"CryptoCompare API key is required to stream tickers\"\n        }\n      });\n    }\n  };\n\n  var assets = state.assets,\n      prices = state.prices,\n      tickers = state.tickers;\n  var providerValue = {\n    assets: assets,\n    prices: prices,\n    tickers: tickers,\n    getAssets: getAssets,\n    streamPrices: streamPrices,\n    streamTickers: streamTickers\n  };\n  return React.createElement(CryptoPriceContext.Provider, {\n    value: providerValue\n  }, children);\n}","map":{"version":3,"sources":["../src/CryptoPriceProvider.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAP,IAAgB,UAAhB,EAA4B,SAA5B,QAA6C,OAA7C;AACA,SAAS,kBAAT,QAAmC,sBAAnC;AACA,OAAO,kBAAP,MAA+B,sBAA/B;AACA,OAAO,KAAP,MAAkB,OAAlB;AACA,SAAS,eAAT,EAA0B,YAA1B,QAA8C,UAA9C;AACA,SACI,aADJ,EAEI,aAFJ,EAGI,UAHJ,EAII,WAJJ,EAKI,YALJ,QAOO,SAPP;AASA,eAAc,SAAU,mBAAV,CAA8B,EAA9B,EAGR;MAFF,mBAAmB,GAAA,EAAA,CAAA,mB;MACnB,QAAQ,GAAA,EAAA,CAAA,Q;AAER,MAAM,YAAY,GAAQ;AACtB,IAAA,MAAM,EAAE,EADc;AAEtB,IAAA,MAAM,EAAE,EAFc;AAGtB,IAAA,OAAO,EAAE,EAHa;AAItB,IAAA,eAAe,EAAE,IAJK;AAKtB,IAAA,gBAAgB,EAAE,IALI;AAMtB,IAAA,WAAW,EAAE,KANS;AAOtB,IAAA,UAAU,EAAE;AAPU,GAA1B;;AAUM,MAAA,EAAA,GAAA,MAAA,CAAoB,UAAU,CAAC,kBAAD,EAAqB,YAArB,CAA9B,EAAgE,CAAhE,CAAA;AAAA,MAAC,KAAK,GAAA,EAAA,CAAA,CAAA,CAAN;AAAA,MAAQ,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAhB;;AAEN,EAAA,SAAS,CAAC,YAAA;AACN,IAAA,SAAS;AACZ,GAFQ,EAEN,EAFM,CAAT;;AAIA,MAAM,SAAS,GAAG,YAAA;AACd,IAAA,KAAK,CAAI,YAAY,GAAA,mBAAhB,CAAL,CACK,IADL,CACU,UAAC,GAAD,EAAI;AACN,MAAA,QAAQ,CAAC;AACL,QAAA,IAAI,EAAE,UADD;AAEL,QAAA,OAAO,EAAE,GAAG,CAAC,IAAJ,CAAS;AAFb,OAAD,CAAR;AAIA,MAAA,QAAQ,CAAC;AACL,QAAA,IAAI,EAAE,WADD;AAEL,QAAA,OAAO,EAAE;AAFJ,OAAD,CAAR;AAIH,KAVL,EAWK,KAXL,CAWW,UAAC,GAAD,EAAI;AAAK,aAAA,OAAO,CAAC,KAAR,CAAA,GAAA,CAAA;AAAkB,KAXtC;AAYH,GAbD;;AAeA,MAAM,iBAAiB,GAAG,UACtB,MADsB,EAEtB,QAFsB,EAGtB,KAHsB,EAGP;AAAf,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,EAAA;AAAe;;AAEf,QAAM,aAAa,GACf,QAAQ,KAAK,IAAb,GAAoB,MAAM,CAAC,IAAP,CAAY,KAAZ,CAApB,GAAyC,MAAM,CAAC,MAAP,CAAc,KAAd,CAD7C;AAEA,QAAM,SAAS,GAAG,MAAM,CAAC,MAAP,CACd,UAAC,KAAD,EAAc;AAAK,aAAA,CAAC,aAAa,CAAC,QAAd,CAAD,KAAC,CAAD;AAA8B,KADnC,CAAlB;AAGA,QAAM,aAAa,GAAG,KAAK,CAAC,MAAN,CACjB,MADiB,CACV,UAAC,KAAD,EAAW;AAAK,aAAA,SAAS,CAAC,QAAV,CAAmB,KAAK,CAAxB,QAAwB,CAAxB,CAAA;AAAmC,KADzC,EAEjB,GAFiB,CAEb,UAAC,KAAD,EAAW;AAAK,aAAC;AAClB,QAAA,EAAE,EAAE,KAAK,CAAC,EADQ;AAElB,QAAA,MAAM,EAAE,KAAK,CAAC,MAAN,CAAa,WAAb;AAFU,OAAD;AAGnB,KALgB,CAAtB;;AAOA,QAAM,WAAW,GAAA,QAAA,CAAA,EAAA,EAAa,KAAb,CAAjB;;AACA,IAAA,aAAa,CAAC,OAAd,CACI,UAAC,MAAD,EAAY;AAAK,aAAC,WAAW,CAAC,MAAM,CAAC,EAAR,CAAX,GAAyB,MAAM,CAAhC,MAAA;AAAwC,KAD7D;AAGA,WAAO,WAAP;AACH,GAtBD;;AAwBA,MAAM,aAAa,GAAG,UAAC,OAAD,EAAuB;AACzC,IAAA,KAAK,CAAC,eAAN,GAAwB,IAAI,SAAJ,CACjB,eAAe,GAAA,gBAAf,GAAgC,OAAO,CAAC,IAAR,CAAa,GAAb,CADf,CAAxB;;AAGA,IAAA,KAAK,CAAC,eAAN,CAAsB,OAAtB,GAAgC,UAAU,CAAV,EAAgB;AAC5C,MAAA,OAAO,CAAC,GAAR,CACI,iDADJ,EAEI,CAAC,CAAC,MAFN;AAIA,MAAA,UAAU,CAAC,YAAA;AACP,QAAA,aAAa,CAAC,OAAD,CAAb;AACH,OAFS,EAEP,IAFO,CAAV;AAGH,KARD;;AAUA,IAAA,KAAK,CAAC,eAAN,CAAsB,OAAtB,GAAgC,UAAU,GAAV,EAAkB;AAC9C,MAAA,OAAO,CAAC,KAAR,CACI,kCADJ,EAEI,GAAG,CAAC,OAFR,EAGI,gBAHJ;AAKA,MAAA,KAAK,CAAC,eAAN,CAAsB,KAAtB;AACH,KAPD;;AASA,IAAA,KAAK,CAAC,eAAN,CAAsB,SAAtB,GAAkC,UAAC,GAAD,EAAS;AACvC,UAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,GAAG,CAAC,IAAf,CAAb;AACA,UAAM,SAAS,GAAkB,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAjC;;AACA,UAAI,KAAK,CAAC,MAAN,CAAa,MAAb,GAAsB,CAA1B,EAA6B;AAEzB,YAAM,aAAW,GAAQ,iBAAiB,CACtC,SADsC,EAEtC,IAFsC,EAGtC,KAAK,CAAC,UAHgC,CAA1C;AAKA,YAAM,iBAAe,GAAQ,EAA7B;AACA,QAAA,SAAS,CAAC,OAAV,CAAkB,UAAC,QAAD,EAAiB;AAC/B,UAAA,iBAAe,CAAC,aAAW,CAAC,QAAD,CAAZ,CAAf,GAAyC,UAAU,CAC/C,IAAI,CAAC,QAAD,CAD2C,CAAnD;AAGH,SAJD;AAKA,QAAA,QAAQ,CAAC;AACL,UAAA,IAAI,EAAE,YADD;AAEL,UAAA,OAAO,EAAE;AAFJ,SAAD,CAAR;AAIA,QAAA,QAAQ,CAAC;AACL,UAAA,IAAI,EAAE,aADD;AAEL,UAAA,OAAO,EAAE;AAFJ,SAAD,CAAR;AAIH;AACJ,KAzBD;AA0BH,GAjDD;;AAmDA,MAAM,cAAc,GAAG,UAAC,OAAD,EAAuB;AAC1C,IAAA,KAAK,CAAC,gBAAN,GAAyB,IAAI,SAAJ,CACrB,gDAA8C,mBADzB,CAAzB;;AAIA,IAAA,KAAK,CAAC,gBAAN,CAAuB,MAAvB,GAAgC,SAAS,YAAT,GAAqB;AACjD,UAAM,UAAU,GAAG;AACf,QAAA,MAAM,EAAE,QADO;AAEf,QAAA,IAAI,EAAE,OAAO,CAAC,GAAR,CACF,UAAC,MAAD,EAAe;AACX,iBAAA,eAAa,MAAM,CAAC,WAAP,EAAb,GAAiC,QAAjC;AAAyC,SAF3C;AAFS,OAAnB;AAOA,MAAA,KAAK,CAAC,gBAAN,CAAuB,IAAvB,CAA4B,IAAI,CAAC,SAAL,CAAe,UAAf,CAA5B;AACH,KATD;;AAUA,IAAA,KAAK,CAAC,gBAAN,CAAuB,OAAvB,GAAiC,UAAU,CAAV,EAAgB;AAC7C,MAAA,OAAO,CAAC,GAAR,CACI,kDADJ,EAEI,CAAC,CAAC,MAFN;AAIA,MAAA,UAAU,CAAC,YAAA;AACP,QAAA,cAAc,CAAC,OAAD,CAAd;AACH,OAFS,EAEP,IAFO,CAAV;AAGH,KARD;;AAUA,IAAA,KAAK,CAAC,gBAAN,CAAuB,OAAvB,GAAiC,UAAU,GAAV,EAAkB;AAC/C,MAAA,OAAO,CAAC,KAAR,CACI,mCADJ,EAEI,GAAG,CAAC,OAFR,EAGI,gBAHJ;AAKA,MAAA,KAAK,CAAC,gBAAN,CAAuB,KAAvB;AACH,KAPD;;AASA,IAAA,KAAK,CAAC,gBAAN,CAAuB,SAAvB,GAAmC,UAAU,OAAV,EAAsB;;;AACrD,UAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,OAAO,CAAC,IAAnB,CAAb;;AACA,UACI,IAAI,CAAC,IAAL,KAAc,IAAd,KACC,IAAI,CAAC,MAAL,KAAgB,GAAhB,IAAuB,IAAI,CAAC,MAAL,KAAgB,GADxC,CADJ,EAGE;AACE,YAAM,WAAW,GAAQ,KAAK,CAAC,OAA/B;AACA,YAAM,MAAM,GAAW,IAAI,CAAC,UAAL,CAAgB,WAAhB,EAAvB;;AACA,YAAI,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,QAAzB,CAAkC,MAAlC,CAAJ,EAA+C;AAC3C,cACI,KAAK,CAAC,OAAN,CAAc,MAAd,EAAsB,SAAtB,GACA,IAAI,IAAJ,CAAS,IAAI,CAAC,EAAL,GAAU,IAAnB,CAFJ,EAGE;AAEE,gBAAM,eAAe,GAAY;AAC7B,cAAA,SAAS,EAAE,IAAI,IAAJ,CAAS,IAAI,CAAC,EAAL,GAAU,IAAnB,CADkB;AAE7B,cAAA,IAAI,EAAE,IAAI,CAAC,IAFkB;AAG7B,cAAA,IAAI,EAAE,IAAI,CAAC,KAHkB;AAI7B,cAAA,GAAG,EAAE,IAAI,CAAC,GAJmB;AAK7B,cAAA,KAAK,EAAE,IAAI,CAAC,KALiB;AAM7B,cAAA,MAAM,EAAE,IAAI,CAAC;AANgB,aAAjC;AAQA,gBAAM,OAAO,IAAA,EAAA,GAAA,EAAA,EACT,EAAA,CAAC,IAAI,CAAC,UAAL,CAAgB,WAAhB,EAAD,CAAA,GAAiC,eADxB,EAEZ,EAFY,CAAb;AAGA,YAAA,QAAQ,CAAC;AACL,cAAA,IAAI,EAAE,aADD;AAEL,cAAA,OAAO,EAAE;AAFJ,aAAD,CAAR;AAIH;AACJ,SAtBD,MAsBO;AACH,cAAM,eAAe,GAAY;AAC7B,YAAA,SAAS,EAAE,IAAI,IAAJ,CAAS,IAAI,CAAC,EAAL,GAAU,IAAnB,CADkB;AAE7B,YAAA,IAAI,EAAE,IAAI,CAAC,IAFkB;AAG7B,YAAA,IAAI,EAAE,IAAI,CAAC,KAHkB;AAI7B,YAAA,GAAG,EAAE,IAAI,CAAC,GAJmB;AAK7B,YAAA,KAAK,EAAE,IAAI,CAAC,KALiB;AAM7B,YAAA,MAAM,EAAE,IAAI,CAAC;AANgB,WAAjC;AAQA,cAAM,OAAO,IAAA,EAAA,GAAA,EAAA,EACT,EAAA,CAAC,IAAI,CAAC,UAAL,CAAgB,WAAhB,EAAD,CAAA,GAAiC,eADxB,EAEZ,EAFY,CAAb;AAGA,UAAA,QAAQ,CAAC;AACL,YAAA,IAAI,EAAE,aADD;AAEL,YAAA,OAAO,EAAE;AAFJ,WAAD,CAAR;AAIH;AACJ;AACJ,KAhDD;AAiDH,GAnFD;;AAqFA,MAAM,YAAY,GAAG,UAAC,OAAD,EAAuB;AACxC,QAAM,WAAW,GAAQ,iBAAiB,CACtC,OAAO,CAAC,GAAR,CAAY,UAAC,CAAD,EAAU;AAAK,aAAA,CAAC,CAAD,WAAA,EAAA;AAAe,KAA1C,CADsC,EAEtC,QAFsC,CAA1C;AAIA,IAAA,QAAQ,CAAC;AACL,MAAA,IAAI,EAAE,YADD;AAEL,MAAA,OAAO,EAAE;AAFJ,KAAD,CAAR;AAKA,IAAA,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,WAAZ,CAAV;AACA,IAAA,aAAa,CAAC,OAAD,CAAb;AACH,GAZD;;AAcA,MAAM,aAAa,GAAG,UAAC,OAAD,EAAuB;AACzC,QAAI,mBAAJ,EAAyB;AACrB,MAAA,cAAc,CAAC,OAAD,CAAd;AACH,KAFD,MAEO;AACH,MAAA,QAAQ,CAAC;AACL,QAAA,IAAI,EAAE,aADD;AAEL,QAAA,OAAO,EAAE;AACL,UAAA,KAAK,EAAE;AADF;AAFJ,OAAD,CAAR;AAMH;AACJ,GAXD;;AAaQ,MAAA,MAAM,GAAsB,KAAK,CAA3B,MAAN;AAAA,MAAQ,MAAM,GAAc,KAAK,CAAnB,MAAd;AAAA,MAAgB,OAAO,GAAK,KAAK,CAAV,OAAvB;AACR,MAAM,aAAa,GAAQ;AACvB,IAAA,MAAM,EAAA,MADiB;AAEvB,IAAA,MAAM,EAAA,MAFiB;AAGvB,IAAA,OAAO,EAAA,OAHgB;AAIvB,IAAA,SAAS,EAAA,SAJc;AAKvB,IAAA,YAAY,EAAA,YALW;AAMvB,IAAA,aAAa,EAAA;AANU,GAA3B;AASA,SACI,KAAA,CAAA,aAAA,CAAC,kBAAkB,CAAC,QAApB,EAA4B;AAAC,IAAA,KAAK,EAAE;AAAR,GAA5B,EACK,QADL,CADJ;AAKH","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport React, { useReducer, useEffect } from \"react\";\nimport { CryptoPriceReducer } from \"./CryptoPriceReducer\";\nimport CryptoPriceContext from \"./CryptoPriceContext\";\nimport axios from \"axios\";\nimport { COIN_CAP_WS_URI, COIN_CAP_URI } from \"./config\";\nimport { STREAM_PRICES, STREAM_TICKER, GET_ASSETS, INITIALIZED, CACHE_ASSETS, } from \"./types\";\nexport default function CryptoPriceProvider(_a) {\n    var cryptoCompareApiKey = _a.cryptoCompareApiKey, children = _a.children;\n    var initialState = {\n        assets: [],\n        prices: {},\n        tickers: {},\n        pricesWebSocket: null,\n        tickersWebSocket: null,\n        initialized: false,\n        assetCache: {},\n    };\n    var _b = __read(useReducer(CryptoPriceReducer, initialState), 2), state = _b[0], dispatch = _b[1];\n    useEffect(function () {\n        getAssets();\n    }, []);\n    var getAssets = function () {\n        axios(COIN_CAP_URI + \"assets?limit=1500\")\n            .then(function (res) {\n            dispatch({\n                type: GET_ASSETS,\n                payload: res.data.data,\n            });\n            dispatch({\n                type: INITIALIZED,\n                payload: true,\n            });\n        })\n            .catch(function (err) { return console.error(err); });\n    };\n    var resolveAssetCache = function (assets, matchKey, cache) {\n        if (cache === void 0) { cache = {}; }\n        var cachedSymbols = matchKey === \"id\" ? Object.keys(cache) : Object.values(cache);\n        var newAssets = assets.filter(function (asset) { return !cachedSymbols.includes(asset); });\n        var mappedSymbols = state.assets\n            .filter(function (asset) { return newAssets.includes(asset[matchKey]); })\n            .map(function (asset) { return ({\n            id: asset.id,\n            symbol: asset.symbol.toLowerCase(),\n        }); });\n        var mapperCache = __assign({}, cache);\n        mappedSymbols.forEach(function (symMap) { return (mapperCache[symMap.id] = symMap.symbol); });\n        return mapperCache;\n    };\n    var connectPrices = function (symbols) {\n        state.pricesWebSocket = new WebSocket(COIN_CAP_WS_URI + \"prices?assets=\" + symbols.join(\",\"));\n        state.pricesWebSocket.onclose = function (e) {\n            console.log(\"Price socket closed...reconnecting in 1 second.\", e.reason);\n            setTimeout(function () {\n                connectPrices(symbols);\n            }, 1000);\n        };\n        state.pricesWebSocket.onerror = function (err) {\n            console.error(\"Price socket encountered error: \", err.message, \"Closing socket\");\n            state.pricesWebSocket.close();\n        };\n        state.pricesWebSocket.onmessage = function (msg) {\n            var data = JSON.parse(msg.data);\n            var symbolIds = Object.keys(data);\n            if (state.assets.length > 0) {\n                var mapperCache_1 = resolveAssetCache(symbolIds, \"id\", state.assetCache);\n                var formattedPrices_1 = {};\n                symbolIds.forEach(function (symbolId) {\n                    formattedPrices_1[mapperCache_1[symbolId]] = parseFloat(data[symbolId]);\n                });\n                dispatch({\n                    type: CACHE_ASSETS,\n                    payload: mapperCache_1,\n                });\n                dispatch({\n                    type: STREAM_PRICES,\n                    payload: formattedPrices_1,\n                });\n            }\n        };\n    };\n    var connectTickers = function (symbols) {\n        state.tickersWebSocket = new WebSocket(\"wss://streamer.cryptocompare.com/v2?apiKey=\" + cryptoCompareApiKey);\n        state.tickersWebSocket.onopen = function onStreamOpen() {\n            var subRequest = {\n                action: \"SubAdd\",\n                subs: symbols.map(function (symbol) {\n                    return \"24~CCCAGG~\" + symbol.toUpperCase() + \"~USD~m\";\n                }),\n            };\n            state.tickersWebSocket.send(JSON.stringify(subRequest));\n        };\n        state.tickersWebSocket.onclose = function (e) {\n            console.log(\"Ticker socket closed...reconnecting in 1 second.\", e.reason);\n            setTimeout(function () {\n                connectTickers(symbols);\n            }, 1000);\n        };\n        state.tickersWebSocket.onerror = function (err) {\n            console.error(\"Ticker socket encountered error: \", err.message, \"Closing socket\");\n            state.tickersWebSocket.close();\n        };\n        state.tickersWebSocket.onmessage = function (message) {\n            var _a, _b;\n            var data = JSON.parse(message.data);\n            if (data.TYPE === \"24\" &&\n                (data.ACTION === \"A\" || data.ACTION === \"I\")) {\n                var tickersCopy = state.tickers;\n                var symbol = data.FROMSYMBOL.toLowerCase();\n                if (Object.keys(tickersCopy).includes(symbol)) {\n                    if (state.tickers[symbol].timestamp <\n                        new Date(data.TS * 1000)) {\n                        var formattedTicker = {\n                            timestamp: new Date(data.TS * 1000),\n                            open: data.OPEN,\n                            high: data.CLOSE,\n                            low: data.LOW,\n                            close: data.CLOSE,\n                            volume: data.VOLUMETO,\n                        };\n                        var payload = (_a = {},\n                            _a[data.FROMSYMBOL.toLowerCase()] = formattedTicker,\n                            _a);\n                        dispatch({\n                            type: STREAM_TICKER,\n                            payload: payload,\n                        });\n                    }\n                }\n                else {\n                    var formattedTicker = {\n                        timestamp: new Date(data.TS * 1000),\n                        open: data.OPEN,\n                        high: data.CLOSE,\n                        low: data.LOW,\n                        close: data.CLOSE,\n                        volume: data.VOLUMETO,\n                    };\n                    var payload = (_b = {},\n                        _b[data.FROMSYMBOL.toLowerCase()] = formattedTicker,\n                        _b);\n                    dispatch({\n                        type: STREAM_TICKER,\n                        payload: payload,\n                    });\n                }\n            }\n        };\n    };\n    var streamPrices = function (symbols) {\n        var symbolCache = resolveAssetCache(symbols.map(function (s) { return s.toUpperCase(); }), \"symbol\");\n        dispatch({\n            type: CACHE_ASSETS,\n            payload: symbolCache,\n        });\n        symbols = Object.keys(symbolCache);\n        connectPrices(symbols);\n    };\n    var streamTickers = function (symbols) {\n        if (cryptoCompareApiKey) {\n            connectTickers(symbols);\n        }\n        else {\n            dispatch({\n                type: STREAM_TICKER,\n                payload: {\n                    error: \"CryptoCompare API key is required to stream tickers\",\n                },\n            });\n        }\n    };\n    var assets = state.assets, prices = state.prices, tickers = state.tickers;\n    var providerValue = {\n        assets: assets,\n        prices: prices,\n        tickers: tickers,\n        getAssets: getAssets,\n        streamPrices: streamPrices,\n        streamTickers: streamTickers,\n    };\n    return (React.createElement(CryptoPriceContext.Provider, { value: providerValue }, children));\n}\n//# sourceMappingURL=CryptoPriceProvider.js.map"]},"metadata":{},"sourceType":"module"}