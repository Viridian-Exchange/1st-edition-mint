{"ast":null,"code":"/*******************************************\n * THIS IS THE EIP-712 SIGN IMPLEMENTATION *\n *******************************************/\nimport config from \"../local-dev-config\";\nimport vTJSON from \"../abis/MetaTransactionTokenABI.json\";\nimport Web3 from \"web3\";\nimport { Biconomy } from \"@biconomy/mexa\"; //let web3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\") || \"HTTP://127.0.0.1:7545\");\n\nlet walletWeb3 = new Web3(Web3.givenProvider || Web3.providers.HttpProvider(\"https://eth-mainnet.alchemyapi.io/v2/w3ToNmNGlD_uHM3H6CLfkXB0s2FVKY6M\"));\nconst biconomy = new Biconomy(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://eth-mainnet.alchemyapi.io/v2/w3ToNmNGlD_uHM3H6CLfkXB0s2FVKY6M\"), {\n  apiKey: \"l85zqDXIz.da8c87b4-e4eb-431d-8453-0bfef42c3fa2\",\n  debug: true\n});\nlet biconomyWeb3 = new Web3(biconomy); // biconomy.onEvent(biconomy.READY, () => {\n//     // Initialize your dapp here like getting user accounts etc\n//     //alert(\"initialized\");\n// }).onEvent(biconomy.ERROR, (error, message) => {\n//     // Handle error while initializing mexa\n//     //alert(error);\n// });\n\nconst getSignatureParameters = signature => {\n  if (!walletWeb3.utils.isHexStrict(signature)) {\n    throw new Error('Given value \"'.concat(signature, '\" is not a valid hex string.'));\n  }\n\n  var r = signature.slice(0, 66);\n  var s = \"0x\".concat(signature.slice(66, 130));\n  var v = \"0x\".concat(signature.slice(130, 132));\n  v = walletWeb3.utils.hexToNumber(v);\n  if (![27, 28].includes(v)) v += 27;\n  return {\n    r: r,\n    s: s,\n    v: v\n  };\n};\n\nexport async function approve(fromAddr, exchangeAddress, amount) {\n  const vTContractAddress = '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619'; //let contract = new web3.eth.Contract(vTJSON, vTContractAddress);\n\n  let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n  //let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n  // This web3 instance is used to get user signature from connected wallet\n  //let walletWeb3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\"));\n  // Initialize constants\n\n  const domainType = [{\n    name: \"name\",\n    type: \"string\"\n  }, {\n    name: \"version\",\n    type: \"string\"\n  }, {\n    name: \"verifyingContract\",\n    type: \"address\"\n  }, {\n    name: \"salt\",\n    type: \"bytes32\"\n  }];\n  const metaTransactionType = [{\n    name: \"nonce\",\n    type: \"uint256\"\n  }, {\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"functionSignature\",\n    type: \"bytes\"\n  }]; // replace the chainId 42 if network is not kovan\n  // TODO: Make sure replacing verifyingContract with the WETH contract is correct\n\n  let domainData = {\n    name: \"Wrapped Ether\",\n    version: \"1\",\n    verifyingContract: vTContractAddress,\n    // converts Number to bytes32. Use your chainId instead of 42 if network is not Kovan\n    // TODO: Make sure this is correct\n    salt: '0x' + 137 .toString(16).padStart(64, '0')\n  };\n  let contract = new biconomyWeb3.eth.Contract(vTJSON, vTContractAddress);\n  let nonce = await contract.methods.getNonce(fromAddr).call(); // Create your target method signature.. here we are calling setQuote() method of our contract\n\n  let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n  let message = {};\n  message.nonce = parseInt(nonce);\n  message.from = fromAddr;\n  message.functionSignature = functionSignature;\n  const dataToSign = JSON.stringify({\n    types: {\n      EIP712Domain: domainType,\n      MetaTransaction: metaTransactionType\n    },\n    domain: domainData,\n    primaryType: \"MetaTransaction\",\n    message: message\n  }); // NOTE: Using walletWeb3 here, as it is connected to the wallet where user account is present.\n  // Get the EIP-712 Signature and send the transaction\n\n  walletWeb3.currentProvider.send({\n    jsonrpc: \"2.0\",\n    id: 999999999999,\n    method: \"eth_signTypedData_v4\",\n    params: [fromAddr, dataToSign]\n  }, function (error, response) {\n    // Check github repository for getSignatureParameters helper method\n    let {\n      r,\n      s,\n      v\n    } = getSignatureParameters(response.result);\n    let tx = contract.methods.executeMetaTransaction(fromAddr, functionSignature, r, s, v).send({\n      from: fromAddr\n    });\n    tx.on(\"transactionHash\", function (hash) {// Handle transaction hash\n    }).once(\"confirmation\", function (confirmationNumber, receipt) {\n      // Handle confirmation\n      alert(confirmationNumber);\n    }).on(\"error\", function (error) {\n      // Handle error\n      alert(\"ERROR: \" + JSON.stringify(error));\n    });\n  });\n}\nexport async function allowance(from, exchangeAddress) {\n  //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n  const vTContractAddress = '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619';\n  let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress); //TODO: Figure out why from is wrong\n  //alert(from);\n  //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n  //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n\n  let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n\n  let tx = await vTABI.methods.allowance(from, exchangeAddress).call(); // await tx.on(\"transactionHash\", function (hash) {\n  //     console.log(`Transaction hash is ${hash}`);\n  //     alert(`Transaction sent. Waiting for confirmation ..`);\n  // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n  //     console.log(receipt);\n  //     console.log(receipt.transactionHash);\n  //     //do something with transaction hash\n  // });\n\n  await console.log(JSON.stringify(tx));\n  return tx; //await console.log(JSON.stringify(tx))\n}\nexport async function balanceOf(from) {\n  //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n  const vTContractAddress = '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619';\n  let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress); //TODO: Figure out why from is wrong\n\n  let tx = await vTABI.methods.balanceOf(from).call(); // await tx.on(\"transactionHash\", function (hash) {\n  //     console.log(`Transaction hash is ${hash}`);\n  //     alert(`Transaction sent. Waiting for confirmation ..`);\n  // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n  //     console.log(receipt);\n  //     console.log(receipt.transactionHash);\n  //     //do something with transaction hash\n  // });\n\n  await console.log(JSON.stringify(tx));\n  return tx; //await console.log(JSON.stringify(tx))\n}","map":{"version":3,"sources":["/Users/blakehatch/WebstormProjects/1st-edition-mint/src/smartContracts/ViridianTokenMethods.js"],"names":["config","vTJSON","Web3","Biconomy","walletWeb3","givenProvider","providers","HttpProvider","biconomy","apiKey","debug","biconomyWeb3","getSignatureParameters","signature","utils","isHexStrict","Error","concat","r","slice","s","v","hexToNumber","includes","approve","fromAddr","exchangeAddress","amount","vTContractAddress","infinite_approve_amount","domainType","name","type","metaTransactionType","domainData","version","verifyingContract","salt","toString","padStart","contract","eth","Contract","nonce","methods","getNonce","call","functionSignature","encodeABI","message","parseInt","from","dataToSign","JSON","stringify","types","EIP712Domain","MetaTransaction","domain","primaryType","currentProvider","send","jsonrpc","id","method","params","error","response","result","tx","executeMetaTransaction","on","hash","once","confirmationNumber","receipt","alert","allowance","vTABI","console","log","balanceOf"],"mappings":"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","sourcesContent":["/*******************************************\n * THIS IS THE EIP-712 SIGN IMPLEMENTATION *\n *******************************************/\n\nimport config from \"../local-dev-config\";\nimport vTJSON from \"../abis/MetaTransactionTokenABI.json\";\nimport Web3 from \"web3\";\nimport {Biconomy} from \"@biconomy/mexa\";\n//let web3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider(\"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\") || \"HTTP://127.0.0.1:7545\");\nlet walletWeb3 = new Web3(Web3.givenProvider || Web3.providers.HttpProvider( \"https://eth-mainnet.alchemyapi.io/v2/w3ToNmNGlD_uHM3H6CLfkXB0s2FVKY6M\"));\n\nconst biconomy = new Biconomy(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://eth-mainnet.alchemyapi.io/v2/w3ToNmNGlD_uHM3H6CLfkXB0s2FVKY6M\"),{apiKey: \"l85zqDXIz.da8c87b4-e4eb-431d-8453-0bfef42c3fa2\", debug: true});\n\nlet biconomyWeb3 = new Web3(biconomy);\n\n// biconomy.onEvent(biconomy.READY, () => {\n//     // Initialize your dapp here like getting user accounts etc\n//     //alert(\"initialized\");\n// }).onEvent(biconomy.ERROR, (error, message) => {\n//     // Handle error while initializing mexa\n//     //alert(error);\n// });\n\nconst getSignatureParameters = signature => {\n    if (!walletWeb3.utils.isHexStrict(signature)) {\n        throw new Error(\n            'Given value \"'.concat(signature, '\" is not a valid hex string.')\n        );\n    }\n    var r = signature.slice(0, 66);\n    var s = \"0x\".concat(signature.slice(66, 130));\n    var v = \"0x\".concat(signature.slice(130, 132));\n    v = walletWeb3.utils.hexToNumber(v);\n    if (![27, 28].includes(v)) v += 27;\n    return {\n        r: r,\n        s: s,\n        v: v\n    };\n};\n\nexport async function approve(fromAddr, exchangeAddress, amount) {\n    const vTContractAddress = '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619';\n\n    //let contract = new web3.eth.Contract(vTJSON, vTContractAddress);\n\n    let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n\n    //let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n\n    // This web3 instance is used to get user signature from connected wallet\n    //let walletWeb3 = new Web3(Web3.givenProvider || new Web3.providers.HttpProvider( \"https://polygon-mumbai.g.alchemy.com/v2/XvPpXkhm8UtkGw9b8tIMcR3vr1zTZd3b\"));\n\n    // Initialize constants\n    const domainType = [\n        { name: \"name\", type: \"string\" },\n        { name: \"version\", type: \"string\" },\n        { name: \"verifyingContract\", type: \"address\" },\n        { name: \"salt\", type: \"bytes32\" },\n    ];\n    const metaTransactionType = [\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"from\", type: \"address\" },\n        { name: \"functionSignature\", type: \"bytes\" }\n    ];\n// replace the chainId 42 if network is not kovan\n    // TODO: Make sure replacing verifyingContract with the WETH contract is correct\n    let domainData = {\n        name: \"Wrapped Ether\",\n        version: \"1\",\n        verifyingContract: vTContractAddress,\n        // converts Number to bytes32. Use your chainId instead of 42 if network is not Kovan\n        // TODO: Make sure this is correct\n        salt: '0x' + (137).toString(16).padStart(64, '0')\n    };\n\n\n        let contract = new biconomyWeb3.eth.Contract(\n            vTJSON,\n            vTContractAddress);\n\n                    let nonce = await contract.methods.getNonce(fromAddr).call();\n                    // Create your target method signature.. here we are calling setQuote() method of our contract\n                    let functionSignature = contract.methods.approve(exchangeAddress, infinite_approve_amount).encodeABI();\n                    let message = {};\n                    message.nonce = parseInt(nonce);\n                    message.from = fromAddr;\n                    message.functionSignature = functionSignature;\n\n                    const dataToSign = JSON.stringify({\n                    types: {\n                    EIP712Domain: domainType,\n                    MetaTransaction: metaTransactionType\n                },\n                    domain: domainData,\n                    primaryType: \"MetaTransaction\",\n                    message: message\n                });\n\n                    // NOTE: Using walletWeb3 here, as it is connected to the wallet where user account is present.\n                    // Get the EIP-712 Signature and send the transaction\n                    walletWeb3.currentProvider.send({\n                    jsonrpc: \"2.0\",\n                    id: 999999999999,\n                    method: \"eth_signTypedData_v4\",\n                    params: [fromAddr, dataToSign]\n                },function(error, response) {\n                    // Check github repository for getSignatureParameters helper method\n                    let { r, s, v } = getSignatureParameters(response.result);\n\n                    let tx = contract.methods.executeMetaTransaction(fromAddr,\n                    functionSignature, r, s, v)\n                    .send({from: fromAddr});\n\n                    tx.on(\"transactionHash\", function(hash) {\n                    // Handle transaction hash\n                }).once(\"confirmation\", function(confirmationNumber, receipt) {\n                    // Handle confirmation\n                        alert(confirmationNumber);\n                }).on(\"error\", function(error) {\n                    // Handle error\n                        alert(\"ERROR: \" + JSON.stringify(error));\n                });\n\n                }\n                    );\n}\n\nexport async function allowance(from, exchangeAddress) {\n    //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n\n    const vTContractAddress = '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619';\n\n    let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress);\n\n\n    //TODO: Figure out why from is wrong\n    //alert(from);\n\n    //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n    //alert(await vTABI.methods.allowance(from, exchangeAddress).call());\n\n    let infinite_approve_amount = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; //(2^256 - 1 )\n\n    let tx = await vTABI.methods.allowance(from, exchangeAddress).call();\n\n    // await tx.on(\"transactionHash\", function (hash) {\n    //     console.log(`Transaction hash is ${hash}`);\n    //     alert(`Transaction sent. Waiting for confirmation ..`);\n    // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n    //     console.log(receipt);\n    //     console.log(receipt.transactionHash);\n    //     //do something with transaction hash\n    // });\n\n    await console.log(JSON.stringify(tx))\n\n    return tx;\n    //await console.log(JSON.stringify(tx))\n}\n\nexport async function balanceOf(from) {\n    //const vTContractAddress = config.mumbai_contract_addresses.vt_contract;\n\n    const vTContractAddress = '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619';\n\n    let vTABI = new walletWeb3.eth.Contract(vTJSON, vTContractAddress);\n\n\n    //TODO: Figure out why from is wrong\n\n    let tx = await vTABI.methods.balanceOf(from).call();\n\n    // await tx.on(\"transactionHash\", function (hash) {\n    //     console.log(`Transaction hash is ${hash}`);\n    //     alert(`Transaction sent. Waiting for confirmation ..`);\n    // }).once(\"confirmation\", function (confirmationNumber, receipt) {\n    //     console.log(receipt);\n    //     console.log(receipt.transactionHash);\n    //     //do something with transaction hash\n    // });\n\n    await console.log(JSON.stringify(tx))\n\n    return tx;\n    //await console.log(JSON.stringify(tx))\n}"]},"metadata":{},"sourceType":"module"}